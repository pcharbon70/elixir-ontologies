defmodule ElixirOntologies.Extractors.Evolution.ActivityModel do
  @moduledoc """
  Models development activities using PROV-O Activity class.

  This module extends the activity classification to provide full PROV-O
  modeling with temporal relationships, entity usage/generation, and
  activity chains.

  ## PROV-O Alignment

  Aligns with elixir-evolution.ttl ontology concepts:
  - `evolution:DevelopmentActivity` - subclass of `prov:Activity`
  - `evolution:Commit` - subclass of `DevelopmentActivity`
  - `prov:used` - entities consumed by activity
  - `prov:generated` - entities produced by activity
  - `prov:wasInformedBy` - activity informed by another activity
  - `prov:startedAtTime` / `prov:endedAtTime` - temporal bounds

  ## Activity Identification

  Activity IDs follow the pattern: `activity:{short_sha}`
  For example: `activity:abc123d`

  ## Usage

      alias ElixirOntologies.Extractors.Evolution.ActivityModel

      # Extract activity model from commit
      {:ok, commit} = Commit.extract_commit(".", "HEAD")
      {:ok, activity} = ActivityModel.extract_activity(".", commit)

      activity.used_entities
      # => ["MyApp.User@def456e"]

      activity.generated_entities
      # => ["MyApp.User@abc123d"]

  ## Examples

      iex> alias ElixirOntologies.Extractors.Evolution.ActivityModel
      iex> alias ElixirOntologies.Extractors.Evolution.Commit
      iex> {:ok, commit} = Commit.extract_commit(".", "HEAD")
      iex> {:ok, activity} = ActivityModel.extract_activity(".", commit)
      iex> String.starts_with?(activity.activity_id, "activity:")
      true
  """

  alias ElixirOntologies.Analyzer.Git
  alias ElixirOntologies.Extractors.Evolution.Commit
  alias ElixirOntologies.Extractors.Evolution.GitUtils

  # ===========================================================================
  # ActivityModel Struct
  # ===========================================================================

  defmodule ActivityModel do
    @moduledoc """
    Represents a PROV-O Activity with full provenance relationships.

    Aligns with `evolution:DevelopmentActivity` and `prov:Activity`.
    """

    @type t :: %__MODULE__{
            activity_id: String.t(),
            activity_type: atom(),
            commit_sha: String.t(),
            short_sha: String.t(),
            started_at: DateTime.t() | nil,
            ended_at: DateTime.t() | nil,
            used_entities: [String.t()],
            generated_entities: [String.t()],
            invalidated_entities: [String.t()],
            informed_by: [String.t()],
            informs: [String.t()],
            associated_agents: [String.t()],
            metadata: map()
          }

    @enforce_keys [:activity_id, :activity_type, :commit_sha, :short_sha]
    defstruct [
      :activity_id,
      :activity_type,
      :commit_sha,
      :short_sha,
      :started_at,
      :ended_at,
      used_entities: [],
      generated_entities: [],
      invalidated_entities: [],
      informed_by: [],
      informs: [],
      associated_agents: [],
      metadata: %{}
    ]
  end

  # ===========================================================================
  # Usage Struct (prov:used)
  # ===========================================================================

  defmodule Usage do
    @moduledoc """
    Represents a PROV-O usage relationship (prov:used).

    An activity uses an entity when it reads or depends on that entity.
    """

    @type t :: %__MODULE__{
            activity_id: String.t(),
            entity_id: String.t(),
            role: atom() | nil,
            timestamp: DateTime.t() | nil,
            metadata: map()
          }

    @enforce_keys [:activity_id, :entity_id]
    defstruct [
      :activity_id,
      :entity_id,
      :role,
      :timestamp,
      metadata: %{}
    ]
  end

  # ===========================================================================
  # Generation Struct (prov:wasGeneratedBy)
  # ===========================================================================

  defmodule Generation do
    @moduledoc """
    Represents a PROV-O generation relationship (prov:wasGeneratedBy).

    An entity is generated by an activity when created or modified.
    """

    @type t :: %__MODULE__{
            entity_id: String.t(),
            activity_id: String.t(),
            timestamp: DateTime.t() | nil,
            metadata: map()
          }

    @enforce_keys [:entity_id, :activity_id]
    defstruct [
      :entity_id,
      :activity_id,
      :timestamp,
      metadata: %{}
    ]
  end

  # ===========================================================================
  # Communication Struct (prov:wasInformedBy)
  # ===========================================================================

  defmodule Communication do
    @moduledoc """
    Represents a PROV-O communication relationship (prov:wasInformedBy).

    Activity A was informed by Activity B when A uses entities generated by B.
    """

    @type t :: %__MODULE__{
            informed_activity: String.t(),
            informing_activity: String.t(),
            metadata: map()
          }

    @enforce_keys [:informed_activity, :informing_activity]
    defstruct [
      :informed_activity,
      :informing_activity,
      metadata: %{}
    ]
  end

  # ===========================================================================
  # Public API - Activity Extraction
  # ===========================================================================

  @doc """
  Extracts a PROV-O activity model from a commit.

  ## Options

  - `:include_entities` - Include used/generated entities (default: true)
  - `:include_communications` - Include wasInformedBy relationships (default: true)

  ## Examples

      iex> alias ElixirOntologies.Extractors.Evolution.ActivityModel
      iex> alias ElixirOntologies.Extractors.Evolution.Commit
      iex> {:ok, commit} = Commit.extract_commit(".", "HEAD")
      iex> {:ok, activity} = ActivityModel.extract_activity(".", commit)
      iex> is_binary(activity.activity_id)
      true
  """
  @spec extract_activity(String.t(), Commit.t(), keyword()) ::
          {:ok, ActivityModel.t()} | {:error, atom()}
  def extract_activity(repo_path, commit, opts \\ []) do
    include_entities = Keyword.get(opts, :include_entities, true)
    include_communications = Keyword.get(opts, :include_communications, true)

    with {:ok, repo_root} <- Git.detect_repo(repo_path) do
      activity_id = build_activity_id(commit.short_sha)

      # Get activity type from classification if available
      activity_type = get_activity_type(commit)

      # Extract temporal information
      {started_at, ended_at} = extract_temporal_bounds(commit)

      # Extract entity relationships
      {used, generated, invalidated} =
        if include_entities do
          extract_entity_relationships(repo_root, commit)
        else
          {[], [], []}
        end

      # Extract communication relationships
      informed_by =
        if include_communications do
          extract_informed_by(repo_root, commit)
        else
          []
        end

      {:ok,
       %ActivityModel{
         activity_id: activity_id,
         activity_type: activity_type,
         commit_sha: commit.sha,
         short_sha: commit.short_sha,
         started_at: started_at,
         ended_at: ended_at,
         used_entities: used,
         generated_entities: generated,
         invalidated_entities: invalidated,
         informed_by: informed_by,
         informs: [],
         associated_agents: [],
         metadata: %{}
       }}
    end
  end

  @doc """
  Extracts activity model, raising on error.
  """
  @spec extract_activity!(String.t(), Commit.t(), keyword()) :: ActivityModel.t()
  def extract_activity!(repo_path, commit, opts \\ []) do
    case extract_activity(repo_path, commit, opts) do
      {:ok, activity} -> activity
      {:error, reason} -> raise ArgumentError, "Failed to extract activity: #{reason}"
    end
  end

  @doc """
  Extracts activity models for multiple commits.

  ## Options

  - `:include_entities` - Include used/generated entities (default: true)
  - `:include_communications` - Include wasInformedBy relationships (default: true)
  - `:link_informs` - Populate `informs` field based on `informed_by` (default: true)

  ## Examples

      iex> alias ElixirOntologies.Extractors.Evolution.ActivityModel
      iex> alias ElixirOntologies.Extractors.Evolution.Commit
      iex> {:ok, commits} = Commit.extract_commits(".", limit: 5)
      iex> {:ok, activities} = ActivityModel.extract_activities(".", commits)
      iex> is_list(activities)
      true
  """
  @spec extract_activities(String.t(), [Commit.t()], keyword()) ::
          {:ok, [ActivityModel.t()]} | {:error, atom()}
  def extract_activities(repo_path, commits, opts \\ []) do
    link_informs = Keyword.get(opts, :link_informs, true)

    with {:ok, repo_root} <- Git.detect_repo(repo_path) do
      activities =
        commits
        |> Enum.map(fn commit ->
          case extract_activity(repo_root, commit, opts) do
            {:ok, activity} -> activity
            {:error, _} -> nil
          end
        end)
        |> Enum.reject(&is_nil/1)

      # Link informs relationships (reverse of informed_by)
      activities =
        if link_informs do
          link_informs_relationships(activities)
        else
          activities
        end

      {:ok, activities}
    end
  end

  @doc """
  Extracts activities, raising on error.
  """
  @spec extract_activities!(String.t(), [Commit.t()], keyword()) :: [ActivityModel.t()]
  def extract_activities!(repo_path, commits, opts \\ []) do
    case extract_activities(repo_path, commits, opts) do
      {:ok, activities} -> activities
      {:error, reason} -> raise ArgumentError, "Failed to extract activities: #{reason}"
    end
  end

  # ===========================================================================
  # Public API - Usage Extraction
  # ===========================================================================

  @doc """
  Extracts all usage relationships for an activity.

  Returns Usage structs representing entities used by the activity.

  ## Examples

      iex> alias ElixirOntologies.Extractors.Evolution.ActivityModel
      iex> alias ElixirOntologies.Extractors.Evolution.Commit
      iex> {:ok, commit} = Commit.extract_commit(".", "HEAD")
      iex> {:ok, usages} = ActivityModel.extract_usages(".", commit)
      iex> is_list(usages)
      true
  """
  @spec extract_usages(String.t(), Commit.t()) :: {:ok, [Usage.t()]} | {:error, atom()}
  def extract_usages(repo_path, commit) do
    with {:ok, repo_root} <- Git.detect_repo(repo_path) do
      activity_id = build_activity_id(commit.short_sha)
      usages = extract_usage_structs(repo_root, commit, activity_id)
      {:ok, usages}
    end
  end

  @doc """
  Extracts usages, raising on error.
  """
  @spec extract_usages!(String.t(), Commit.t()) :: [Usage.t()]
  def extract_usages!(repo_path, commit) do
    case extract_usages(repo_path, commit) do
      {:ok, usages} -> usages
      {:error, reason} -> raise ArgumentError, "Failed to extract usages: #{reason}"
    end
  end

  # ===========================================================================
  # Public API - Generation Extraction
  # ===========================================================================

  @doc """
  Extracts all generation relationships for an activity.

  Returns Generation structs representing entities generated by the activity.

  ## Examples

      iex> alias ElixirOntologies.Extractors.Evolution.ActivityModel
      iex> alias ElixirOntologies.Extractors.Evolution.Commit
      iex> {:ok, commit} = Commit.extract_commit(".", "HEAD")
      iex> {:ok, generations} = ActivityModel.extract_generations(".", commit)
      iex> is_list(generations)
      true
  """
  @spec extract_generations(String.t(), Commit.t()) :: {:ok, [Generation.t()]} | {:error, atom()}
  def extract_generations(repo_path, commit) do
    with {:ok, repo_root} <- Git.detect_repo(repo_path) do
      activity_id = build_activity_id(commit.short_sha)
      generations = extract_generation_structs(repo_root, commit, activity_id)
      {:ok, generations}
    end
  end

  @doc """
  Extracts generations, raising on error.
  """
  @spec extract_generations!(String.t(), Commit.t()) :: [Generation.t()]
  def extract_generations!(repo_path, commit) do
    case extract_generations(repo_path, commit) do
      {:ok, generations} -> generations
      {:error, reason} -> raise ArgumentError, "Failed to extract generations: #{reason}"
    end
  end

  # ===========================================================================
  # Public API - Communication Extraction
  # ===========================================================================

  @doc """
  Extracts communication relationships (wasInformedBy) for an activity.

  ## Examples

      iex> alias ElixirOntologies.Extractors.Evolution.ActivityModel
      iex> alias ElixirOntologies.Extractors.Evolution.Commit
      iex> {:ok, commit} = Commit.extract_commit(".", "HEAD")
      iex> {:ok, communications} = ActivityModel.extract_communications(".", commit)
      iex> is_list(communications)
      true
  """
  @spec extract_communications(String.t(), Commit.t()) ::
          {:ok, [Communication.t()]} | {:error, atom()}
  def extract_communications(repo_path, commit) do
    with {:ok, repo_root} <- Git.detect_repo(repo_path) do
      activity_id = build_activity_id(commit.short_sha)
      communications = extract_communication_structs(repo_root, commit, activity_id)
      {:ok, communications}
    end
  end

  @doc """
  Extracts communications, raising on error.
  """
  @spec extract_communications!(String.t(), Commit.t()) :: [Communication.t()]
  def extract_communications!(repo_path, commit) do
    case extract_communications(repo_path, commit) do
      {:ok, communications} -> communications
      {:error, reason} -> raise ArgumentError, "Failed to extract communications: #{reason}"
    end
  end

  # ===========================================================================
  # Public API - Query Functions
  # ===========================================================================

  @doc """
  Builds an activity ID from a short SHA.
  """
  @spec build_activity_id(String.t()) :: String.t()
  def build_activity_id(short_sha) do
    "activity:#{short_sha}"
  end

  @doc """
  Parses an activity ID to extract the short SHA.
  """
  @spec parse_activity_id(String.t()) :: {:ok, String.t()} | {:error, :invalid_format}
  def parse_activity_id("activity:" <> short_sha) do
    {:ok, short_sha}
  end

  def parse_activity_id(_), do: {:error, :invalid_format}

  @doc """
  Checks if an activity generated a specific entity.
  """
  @spec generated?(ActivityModel.t(), String.t()) :: boolean()
  def generated?(activity, entity_id) do
    entity_id in activity.generated_entities
  end

  @doc """
  Checks if an activity used a specific entity.
  """
  @spec used?(ActivityModel.t(), String.t()) :: boolean()
  def used?(activity, entity_id) do
    entity_id in activity.used_entities
  end

  @doc """
  Checks if activity A was informed by activity B.
  """
  @spec informed_by?(ActivityModel.t(), ActivityModel.t() | String.t()) :: boolean()
  def informed_by?(activity, %ActivityModel{activity_id: id}) do
    id in activity.informed_by
  end

  def informed_by?(activity, activity_id) when is_binary(activity_id) do
    activity_id in activity.informed_by
  end

  @doc """
  Gets the duration of an activity in seconds.
  """
  @spec duration(ActivityModel.t()) :: integer() | nil
  def duration(%ActivityModel{started_at: nil}), do: nil
  def duration(%ActivityModel{ended_at: nil}), do: nil

  def duration(%ActivityModel{started_at: started, ended_at: ended}) do
    DateTime.diff(ended, started)
  end

  # ===========================================================================
  # Private - Activity ID and Type
  # ===========================================================================

  defp get_activity_type(commit) do
    # Try to infer activity type from commit message
    subject = commit.subject || ""

    cond do
      String.match?(subject, ~r/^(feat|feature)[\(:]/) -> :feature
      String.match?(subject, ~r/^(fix|bugfix)[\(:]/) -> :bugfix
      String.match?(subject, ~r/^refactor[\(:]/) -> :refactor
      String.match?(subject, ~r/^docs[\(:]/) -> :docs
      String.match?(subject, ~r/^test[\(:]/) -> :test
      String.match?(subject, ~r/^(chore|build)[\(:]/) -> :chore
      String.match?(subject, ~r/^style[\(:]/) -> :style
      String.match?(subject, ~r/^perf[\(:]/) -> :perf
      String.match?(subject, ~r/^ci[\(:]/) -> :ci
      String.match?(subject, ~r/^revert[\(:]/) -> :revert
      String.match?(subject, ~r/^(deps|dep)[\(:]/) -> :deps
      String.match?(subject, ~r/^release[\(:]/) -> :release
      commit.is_merge -> :merge
      true -> :commit
    end
  end

  # ===========================================================================
  # Private - Temporal Extraction
  # ===========================================================================

  defp extract_temporal_bounds(commit) do
    # PROV-O defines:
    # - startedAtTime: when the activity began
    # - endedAtTime: when the activity ended
    #
    # For commits, we use:
    # - started_at: author_date (when changes were authored)
    # - ended_at: commit_date (when commit was created)
    {commit.author_date, commit.commit_date}
  end

  # ===========================================================================
  # Private - Entity Relationships
  # ===========================================================================

  defp extract_entity_relationships(repo_path, commit) do
    # Get files changed in this commit
    case get_changed_files(repo_path, commit.sha) do
      {:ok, changes} ->
        used = extract_used_entity_ids(changes, commit)
        generated = extract_generated_entity_ids(changes, commit)
        invalidated = extract_invalidated_entity_ids(changes, commit)
        {used, generated, invalidated}

      {:error, _} ->
        {[], [], []}
    end
  end

  defp extract_used_entity_ids(changes, commit) do
    # Entities used are the previous versions of modified/deleted files
    changes
    |> Enum.filter(fn {status, _path} -> status in [:modified, :deleted] end)
    |> Enum.flat_map(fn {_status, path} ->
      # Get parent commit for previous version
      case commit.parents do
        [parent_sha | _] ->
          parent_short = String.slice(parent_sha, 0, 7)
          [build_file_entity_id(path, parent_short)]

        [] ->
          []
      end
    end)
  end

  defp extract_generated_entity_ids(changes, commit) do
    # Entities generated are new versions of added/modified files
    changes
    |> Enum.filter(fn {status, _path} -> status in [:added, :modified] end)
    |> Enum.map(fn {_status, path} ->
      build_file_entity_id(path, commit.short_sha)
    end)
  end

  defp extract_invalidated_entity_ids(changes, commit) do
    # Entities invalidated are previous versions replaced by this commit
    changes
    |> Enum.filter(fn {status, _path} -> status == :modified end)
    |> Enum.flat_map(fn {_status, path} ->
      case commit.parents do
        [parent_sha | _] ->
          parent_short = String.slice(parent_sha, 0, 7)
          [build_file_entity_id(path, parent_short)]

        [] ->
          []
      end
    end)
  end

  defp build_file_entity_id(path, short_sha) do
    "#{path}@#{short_sha}"
  end

  defp get_changed_files(repo_path, commit_sha) do
    args = ["diff-tree", "--no-commit-id", "--name-status", "-r", commit_sha]

    case GitUtils.run_git_command(repo_path, args) do
      {:ok, output} ->
        changes =
          output
          |> String.trim()
          |> String.split("\n", trim: true)
          |> Enum.map(&parse_file_status/1)
          |> Enum.reject(&is_nil/1)

        {:ok, changes}

      {:error, reason} ->
        {:error, reason}
    end
  end

  defp parse_file_status(line) do
    case String.split(line, "\t", parts: 2) do
      ["A", path] ->
        {:added, path}

      ["M", path] ->
        {:modified, path}

      ["D", path] ->
        {:deleted, path}

      ["R" <> _, paths] ->
        case String.split(paths, "\t", parts: 2) do
          [_old, new] -> {:modified, new}
          _ -> nil
        end

      _ ->
        nil
    end
  end

  # ===========================================================================
  # Private - Usage and Generation Structs
  # ===========================================================================

  defp extract_usage_structs(repo_path, commit, activity_id) do
    case get_changed_files(repo_path, commit.sha) do
      {:ok, changes} ->
        changes
        |> Enum.filter(fn {status, _path} -> status in [:modified, :deleted] end)
        |> Enum.flat_map(fn {_status, path} ->
          case commit.parents do
            [parent_sha | _] ->
              parent_short = String.slice(parent_sha, 0, 7)
              entity_id = build_file_entity_id(path, parent_short)

              [
                %Usage{
                  activity_id: activity_id,
                  entity_id: entity_id,
                  role: :input,
                  timestamp: commit.author_date,
                  metadata: %{}
                }
              ]

            [] ->
              []
          end
        end)

      {:error, _} ->
        []
    end
  end

  defp extract_generation_structs(repo_path, commit, activity_id) do
    case get_changed_files(repo_path, commit.sha) do
      {:ok, changes} ->
        changes
        |> Enum.filter(fn {status, _path} -> status in [:added, :modified] end)
        |> Enum.map(fn {_status, path} ->
          entity_id = build_file_entity_id(path, commit.short_sha)

          %Generation{
            entity_id: entity_id,
            activity_id: activity_id,
            timestamp: commit.commit_date,
            metadata: %{}
          }
        end)

      {:error, _} ->
        []
    end
  end

  # ===========================================================================
  # Private - Communication Extraction
  # ===========================================================================

  defp extract_informed_by(_repo_path, commit) do
    # Activity is informed by its parent commit activities
    commit.parents
    |> Enum.map(fn parent_sha ->
      parent_short = String.slice(parent_sha, 0, 7)
      build_activity_id(parent_short)
    end)
  end

  defp extract_communication_structs(repo_path, commit, activity_id) do
    informed_by = extract_informed_by(repo_path, commit)

    informed_by
    |> Enum.map(fn informing_id ->
      %Communication{
        informed_activity: activity_id,
        informing_activity: informing_id,
        metadata: %{}
      }
    end)
  end

  # ===========================================================================
  # Private - Link Informs Relationships
  # ===========================================================================

  defp link_informs_relationships(activities) do
    # Build a map of activity_id -> activity for quick lookup
    _activity_map =
      activities
      |> Enum.map(fn a -> {a.activity_id, a} end)
      |> Map.new()

    # For each activity, find which activities it informs
    activities
    |> Enum.map(fn activity ->
      informs =
        activities
        |> Enum.filter(fn other ->
          activity.activity_id in other.informed_by
        end)
        |> Enum.map(& &1.activity_id)

      %{activity | informs: informs}
    end)
  end
end
