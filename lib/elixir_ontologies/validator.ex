defmodule ElixirOntologies.Validator do
  @moduledoc """
  SHACL validation for RDF knowledge graphs.

  This module provides SHACL (Shapes Constraint Language) validation for RDF graphs
  generated by the Elixir code analyzer. It validates graphs against the SHACL shapes
  defined in `priv/ontologies/elixir-shapes.ttl`.

  ## Features

  - Native Elixir SHACL validation (no external dependencies)
  - Validates RDF graphs against SHACL shapes
  - Returns structured validation reports
  - Supports core SHACL constraints (cardinality, type, string, value, qualified)
  - Supports SPARQL-based constraints for complex validation rules
  - Parallel validation for performance
  - Integrates with Mix tasks

  ## Usage

  ### Basic Validation

      # Validate a graph
      {:ok, graph} = ElixirOntologies.analyze_file("lib/my_module.ex")
      {:ok, report} = ElixirOntologies.Validator.validate(graph)

      if report.conforms? do
        IO.puts("Graph is valid!")
      else
        IO.puts("Found \#{length(report.results)} violations")
      end

  ### Validation from Mix Task

      mix elixir_ontologies.analyze --validate

  ### Custom Shapes File

      {:ok, shapes} = RDF.Turtle.read_file("custom-shapes.ttl")
      {:ok, report} = ElixirOntologies.Validator.validate(graph, shapes_graph: shapes)

  ## Validation Reports

  Validation reports (ElixirOntologies.SHACL.Model.ValidationReport) contain:
  - `conforms?`: Boolean indicating overall conformance
  - `results`: List of validation results (violations, warnings, info)

  Each ValidationResult includes:
  - `focus_node`: The RDF node that violated the constraint
  - `path`: The property path that was constrained (nil for node-level constraints)
  - `severity`: `:violation`, `:warning`, or `:info`
  - `source_shape`: The SHACL shape that was violated
  - `message`: Human-readable error message
  - `details`: Map with constraint-specific details

  ## Validation Options

  - `:shapes_graph` - Custom RDF.Graph with SHACL shapes (default: loads elixir-shapes.ttl)
  - `:parallel` - Enable parallel validation (default: true)
  - `:max_concurrency` - Max concurrent tasks (default: System.schedulers_online())
  - `:timeout` - Validation timeout per shape in ms (default: 5000)

  ## Examples

      # Basic validation with default shapes
      {:ok, graph} = ElixirOntologies.analyze_file("lib/my_module.ex")
      {:ok, report} = ElixirOntologies.Validator.validate(graph)

      # Custom shapes
      {:ok, shapes} = RDF.Turtle.read_file("my-shapes.ttl")
      {:ok, report} = ElixirOntologies.Validator.validate(graph, shapes_graph: shapes)

      # Sequential validation (for debugging)
      {:ok, report} = ElixirOntologies.Validator.validate(graph, parallel: false)

      # Custom concurrency and timeout
      {:ok, report} = ElixirOntologies.Validator.validate(graph,
        max_concurrency: 4,
        timeout: 10_000
      )

      # Check results
      if report.conforms? do
        IO.puts("Valid!")
      else
        Enum.each(report.results, fn result ->
          IO.puts("[\#{result.severity}] \#{result.message}")
          IO.puts("  Focus node: \#{inspect(result.focus_node)}")
          if result.path, do: IO.puts("  Path: \#{inspect(result.path)}")
        end)
      end

  ## API Stability

  **Stability**: Public API - This module's public interface is stable and follows semantic versioning.

  - **Breaking Changes**: Will only occur in major version updates (e.g., 1.x → 2.x)
  - **New Features**: May be added in minor version updates (e.g., 1.0 → 1.1)
  - **Bug Fixes**: May occur in patch version updates (e.g., 1.0.0 → 1.0.1)

  **Public API Surface** (Stable):
  - `validate/2` - Domain-specific validation with automatic shape loading
  - `ValidationReport` struct - Validation report structure
  - `ValidationResult` struct - Individual result structure

  ## Migration from pySHACL

  Prior to Phase 11.4, this module used pySHACL (Python-based SHACL validator)
  via the `SHACLEngine` bridge module. As of Phase 11.4, validation is implemented
  natively in Elixir.

  ### What Changed

  **Removed**:
  - `ElixirOntologies.Validator.SHACLEngine` module (Python bridge)
  - `available?/0` function (no longer needed - always available)
  - `installation_instructions/0` function (no installation required)
  - Python/pySHACL dependency

  **API Compatibility**: **No Breaking Changes**

  The `validate/2` function signature remains identical:
  ```elixir
  {:ok, graph} = ElixirOntologies.analyze_file("lib/my_module.ex")
  {:ok, report} = ElixirOntologies.Validator.validate(graph)
  # Works identically before and after Phase 11.4
  ```

  ### Benefits

  1. **Always Available** - No external installation required
  2. **Better Performance** - Native Elixir with parallel validation
  3. **Better Security** - No shell execution
  4. **Better Errors** - Structured Elixir error tuples
  5. **Easier Deployment** - Single BEAM VM
  6. **Easier Testing** - Pure Elixir, no mocking

  ### Known Limitations

  SPARQL constraints with complex subqueries may not execute due to SPARQL.ex
  library limitations. This affects <5% of shapes. All elixir-shapes.ttl
  constraints are fully supported.

  ## Relationship to SHACL Module

  This module (`ElixirOntologies.Validator`) is a **domain-specific facade** for
  Elixir ontology validation. It delegates to `ElixirOntologies.SHACL` for
  general-purpose SHACL validation.

  **Architecture**:
  ```
  ElixirOntologies.Validator (domain-specific facade)
      ↓ delegates to
  ElixirOntologies.SHACL (general-purpose API)
      ↓ orchestrates
  ElixirOntologies.SHACL.Validator (internal engine)
      ↓ uses
  ElixirOntologies.SHACL.Validators.* (constraint validators)
  ```

  **When to Use**:
  - Use `Validator` (this module) when validating Elixir code graphs with
    automatic loading of elixir-shapes.ttl
  - Use `SHACL` directly when validating arbitrary RDF graphs with custom shapes

  **Example**:
  ```elixir
  # Domain-specific (automatic elixir-shapes.ttl loading)
  {:ok, graph} = ElixirOntologies.analyze_file("lib/my_module.ex")
  {:ok, report} = ElixirOntologies.Validator.validate(graph)

  # General-purpose (you provide shapes)
  {:ok, data} = RDF.Turtle.read_file("my_data.ttl")
  {:ok, shapes} = RDF.Turtle.read_file("my_shapes.ttl")
  {:ok, report} = ElixirOntologies.SHACL.validate(data, shapes)
  ```

  **See Also**: `ElixirOntologies.SHACL` for general-purpose SHACL validation

  """

  alias ElixirOntologies.{Graph, SHACL}

  require Logger

  @typedoc "Validation options"
  @type option ::
          {:shapes_graph, RDF.Graph.t()}
          | {:parallel, boolean()}
          | {:max_concurrency, pos_integer()}
          | {:timeout, timeout()}

  @typedoc "Validation result"
  @type validation_result :: {:ok, SHACL.Model.ValidationReport.t()} | {:error, term()}

  @doc """
  Validates an RDF graph against SHACL shapes.

  ## Parameters

  - `graph`: The RDF graph to validate (ElixirOntologies.Graph struct)
  - `opts`: Optional keyword list with:
    - `:shapes_graph` - Custom RDF.Graph with SHACL shapes (default: loads elixir-shapes.ttl)
    - `:parallel` - Enable parallel validation (default: true)
    - `:max_concurrency` - Max concurrent tasks (default: System.schedulers_online())
    - `:timeout` - Validation timeout per shape in ms (default: 5000)

  ## Returns

  - `{:ok, report}` - Validation completed, check `report.conforms?`
  - `{:error, reason}` - Validation error

  ## Examples

      # Validate with default shapes
      {:ok, graph} = ElixirOntologies.analyze_file("lib/my_module.ex")
      {:ok, report} = ElixirOntologies.Validator.validate(graph)

      if report.conforms? do
        IO.puts("Valid!")
      else
        Enum.each(report.results, fn result ->
          IO.puts("Error: \#{result.message}")
        end)
      end

      # Custom shapes file
      {:ok, shapes} = RDF.Turtle.read_file("my-shapes.ttl")
      {:ok, report} = ElixirOntologies.Validator.validate(graph, shapes_graph: shapes)

      # Sequential validation for debugging
      {:ok, report} = ElixirOntologies.Validator.validate(graph, parallel: false)

  """
  @spec validate(Graph.t(), [option()]) :: validation_result()
  def validate(%Graph{graph: rdf_graph}, opts \\ []) do
    with {:ok, shapes_graph} <- get_shapes_graph(opts) do
      # Call native SHACL validator
      SHACL.Validator.run(rdf_graph, shapes_graph, opts)
    end
  end

  # Gets the shapes graph from options or loads default
  @spec get_shapes_graph(keyword()) :: {:ok, RDF.Graph.t()} | {:error, term()}
  defp get_shapes_graph(opts) do
    case Keyword.get(opts, :shapes_graph) do
      nil ->
        # Load default shapes file
        load_default_shapes()

      shapes_graph when is_struct(shapes_graph, RDF.Graph) ->
        {:ok, shapes_graph}

      _ ->
        {:error, :invalid_shapes_graph}
    end
  end

  # Loads the default elixir-shapes.ttl file
  @spec load_default_shapes() :: {:ok, RDF.Graph.t()} | {:error, term()}
  defp load_default_shapes do
    shapes_path = Path.join(:code.priv_dir(:elixir_ontologies), "ontologies/elixir-shapes.ttl")

    case File.exists?(shapes_path) do
      true ->
        case RDF.Turtle.read_file(shapes_path) do
          {:ok, shapes_graph} ->
            {:ok, shapes_graph}

          {:error, reason} ->
            Logger.error("Failed to read shapes file: #{inspect(reason)}")
            {:error, {:shapes_read_error, reason}}
        end

      false ->
        Logger.error("Shapes file not found: #{shapes_path}")
        {:error, :shapes_file_not_found}
    end
  end
end
