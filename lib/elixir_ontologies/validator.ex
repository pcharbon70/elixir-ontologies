defmodule ElixirOntologies.Validator do
  @moduledoc """
  SHACL validation for RDF knowledge graphs.

  This module provides SHACL (Shapes Constraint Language) validation for RDF graphs
  generated by the Elixir code analyzer. It validates graphs against the SHACL shapes
  defined in `priv/ontologies/elixir-shapes.ttl`.

  ## Features

  - Native Elixir SHACL validation (no external dependencies)
  - Validates RDF graphs against SHACL shapes
  - Returns structured validation reports
  - Supports core SHACL constraints (cardinality, type, string, value, qualified)
  - Supports SPARQL-based constraints for complex validation rules
  - Parallel validation for performance
  - Integrates with Mix tasks

  ## Usage

  ### Basic Validation

      # Validate a graph
      {:ok, graph} = ElixirOntologies.analyze_file("lib/my_module.ex")
      {:ok, report} = ElixirOntologies.Validator.validate(graph)

      if report.conforms? do
        IO.puts("Graph is valid!")
      else
        IO.puts("Found \#{length(report.results)} violations")
      end

  ### Validation from Mix Task

      mix elixir_ontologies.analyze --validate

  ### Custom Shapes File

      {:ok, shapes} = RDF.Turtle.read_file("custom-shapes.ttl")
      {:ok, report} = ElixirOntologies.Validator.validate(graph, shapes_graph: shapes)

  ## Validation Reports

  Validation reports (ElixirOntologies.SHACL.Model.ValidationReport) contain:
  - `conforms?`: Boolean indicating overall conformance
  - `results`: List of validation results (violations, warnings, info)

  Each ValidationResult includes:
  - `focus_node`: The RDF node that violated the constraint
  - `path`: The property path that was constrained (nil for node-level constraints)
  - `severity`: `:violation`, `:warning`, or `:info`
  - `source_shape`: The SHACL shape that was violated
  - `message`: Human-readable error message
  - `details`: Map with constraint-specific details

  ## Validation Options

  - `:shapes_graph` - Custom RDF.Graph with SHACL shapes (default: loads elixir-shapes.ttl)
  - `:parallel` - Enable parallel validation (default: true)
  - `:max_concurrency` - Max concurrent tasks (default: System.schedulers_online())
  - `:timeout` - Validation timeout per shape in ms (default: 5000)

  ## Examples

      # Basic validation with default shapes
      {:ok, graph} = ElixirOntologies.analyze_file("lib/my_module.ex")
      {:ok, report} = ElixirOntologies.Validator.validate(graph)

      # Custom shapes
      {:ok, shapes} = RDF.Turtle.read_file("my-shapes.ttl")
      {:ok, report} = ElixirOntologies.Validator.validate(graph, shapes_graph: shapes)

      # Sequential validation (for debugging)
      {:ok, report} = ElixirOntologies.Validator.validate(graph, parallel: false)

      # Custom concurrency and timeout
      {:ok, report} = ElixirOntologies.Validator.validate(graph,
        max_concurrency: 4,
        timeout: 10_000
      )

      # Check results
      if report.conforms? do
        IO.puts("Valid!")
      else
        Enum.each(report.results, fn result ->
          IO.puts("[\#{result.severity}] \#{result.message}")
          IO.puts("  Focus node: \#{inspect(result.focus_node)}")
          if result.path, do: IO.puts("  Path: \#{inspect(result.path)}")
        end)
      end

  """

  alias ElixirOntologies.{Graph, SHACL}

  require Logger

  @typedoc "Validation options"
  @type option ::
          {:shapes_graph, RDF.Graph.t()}
          | {:parallel, boolean()}
          | {:max_concurrency, pos_integer()}
          | {:timeout, timeout()}

  @typedoc "Validation result"
  @type validation_result :: {:ok, SHACL.Model.ValidationReport.t()} | {:error, term()}

  @doc """
  Validates an RDF graph against SHACL shapes.

  ## Parameters

  - `graph`: The RDF graph to validate (ElixirOntologies.Graph struct)
  - `opts`: Optional keyword list with:
    - `:shapes_graph` - Custom RDF.Graph with SHACL shapes (default: loads elixir-shapes.ttl)
    - `:parallel` - Enable parallel validation (default: true)
    - `:max_concurrency` - Max concurrent tasks (default: System.schedulers_online())
    - `:timeout` - Validation timeout per shape in ms (default: 5000)

  ## Returns

  - `{:ok, report}` - Validation completed, check `report.conforms?`
  - `{:error, reason}` - Validation error

  ## Examples

      # Validate with default shapes
      {:ok, graph} = ElixirOntologies.analyze_file("lib/my_module.ex")
      {:ok, report} = ElixirOntologies.Validator.validate(graph)

      if report.conforms? do
        IO.puts("Valid!")
      else
        Enum.each(report.results, fn result ->
          IO.puts("Error: \#{result.message}")
        end)
      end

      # Custom shapes file
      {:ok, shapes} = RDF.Turtle.read_file("my-shapes.ttl")
      {:ok, report} = ElixirOntologies.Validator.validate(graph, shapes_graph: shapes)

      # Sequential validation for debugging
      {:ok, report} = ElixirOntologies.Validator.validate(graph, parallel: false)

  """
  @spec validate(Graph.t(), [option()]) :: validation_result()
  def validate(%Graph{graph: rdf_graph}, opts \\ []) do
    with {:ok, shapes_graph} <- get_shapes_graph(opts) do
      # Call native SHACL validator
      SHACL.Validator.run(rdf_graph, shapes_graph, opts)
    end
  end

  # Gets the shapes graph from options or loads default
  @spec get_shapes_graph(keyword()) :: {:ok, RDF.Graph.t()} | {:error, term()}
  defp get_shapes_graph(opts) do
    case Keyword.get(opts, :shapes_graph) do
      nil ->
        # Load default shapes file
        load_default_shapes()

      shapes_graph when is_struct(shapes_graph, RDF.Graph) ->
        {:ok, shapes_graph}

      _ ->
        {:error, :invalid_shapes_graph}
    end
  end

  # Loads the default elixir-shapes.ttl file
  @spec load_default_shapes() :: {:ok, RDF.Graph.t()} | {:error, term()}
  defp load_default_shapes do
    shapes_path = Path.join(:code.priv_dir(:elixir_ontologies), "ontologies/elixir-shapes.ttl")

    case File.exists?(shapes_path) do
      true ->
        case RDF.Turtle.read_file(shapes_path) do
          {:ok, shapes_graph} ->
            {:ok, shapes_graph}

          {:error, reason} ->
            Logger.error("Failed to read shapes file: #{inspect(reason)}")
            {:error, {:shapes_read_error, reason}}
        end

      false ->
        Logger.error("Shapes file not found: #{shapes_path}")
        {:error, :shapes_file_not_found}
    end
  end
end
