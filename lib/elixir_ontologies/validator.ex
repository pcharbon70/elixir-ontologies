defmodule ElixirOntologies.Validator do
  @moduledoc """
  SHACL validation for RDF knowledge graphs.

  This module provides SHACL (Shapes Constraint Language) validation for RDF graphs
  generated by the Elixir code analyzer. It validates graphs against the SHACL shapes
  defined in `priv/ontologies/elixir-shapes.ttl`.

  ## Features

  - Validates RDF graphs against SHACL shapes
  - Returns structured validation reports
  - Detects pySHACL availability
  - Provides clear error messages
  - Integrates with Mix tasks

  ## Requirements

  This module requires pySHACL to be installed on your system. pySHACL is a Python
  library that provides SHACL validation.

  To install pySHACL:

      pip install pyshacl

  To check if pySHACL is available:

      ElixirOntologies.Validator.available?()

  ## Usage

  ### Basic Validation

      # Validate a graph
      {:ok, graph} = ElixirOntologies.analyze_file("lib/my_module.ex")
      {:ok, report} = ElixirOntologies.Validator.validate(graph)

      if report.conforms do
        IO.puts("Graph is valid!")
      else
        IO.puts("Found \#{length(report.violations)} violations")
      end

  ### Validation from Mix Task

      mix elixir_ontologies.analyze --validate

  ### Custom Shapes File

      {:ok, report} = ElixirOntologies.Validator.validate(graph, shapes_file: "custom-shapes.ttl")

  ## Validation Reports

  Validation reports contain:
  - `conforms`: Boolean indicating overall conformance
  - `violations`: List of constraint violations (errors)
  - `warnings`: List of warnings (non-critical issues)
  - `info`: List of informational messages

  Each violation/warning/info includes:
  - `focus_node`: The RDF node that violated the constraint
  - `result_path`: The property path that was constrained
  - `value`: The actual value that violated the constraint
  - `message`: Human-readable error message
  - `severity`: `:violation`, `:warning`, or `:info`
  - `source_shape`: The SHACL shape that was violated
  - `constraint_component`: Which SHACL constraint failed

  ## Error Handling

  If pySHACL is not available, the validator will return:

      {:error, :pyshacl_not_available}

  You can check availability and get installation instructions:

      unless ElixirOntologies.Validator.available?() do
        IO.puts(ElixirOntologies.Validator.installation_instructions())
      end

  """

  alias ElixirOntologies.{Graph, Validator}
  alias Validator.{Report, ReportParser, ShaclEngine}

  require Logger

  @typedoc "Validation options"
  @type option ::
          {:shapes_file, Path.t()}
          | {:timeout, non_neg_integer()}

  @typedoc "Validation result"
  @type validation_result :: {:ok, Report.t()} | {:error, term()}

  @doc """
  Validates an RDF graph against SHACL shapes.

  ## Parameters

  - `graph`: The RDF graph to validate (ElixirOntologies.Graph struct)
  - `opts`: Optional keyword list with:
    - `:shapes_file` - Path to SHACL shapes file (default: priv/ontologies/elixir-shapes.ttl)
    - `:timeout` - Validation timeout in milliseconds (default: 30000)

  ## Returns

  - `{:ok, report}` - Validation completed, check `report.conforms`
  - `{:error, :pyshacl_not_available}` - pySHACL not installed
  - `{:error, reason}` - Validation error

  ## Examples

      # Validate a graph
      {:ok, graph} = ElixirOntologies.analyze_file("lib/my_module.ex")
      {:ok, report} = ElixirOntologies.Validator.validate(graph)

      # Check conformance
      if report.conforms do
        IO.puts("Valid!")
      else
        Enum.each(report.violations, fn violation ->
          IO.puts("Error: \#{violation.message}")
        end)
      end

      # Custom shapes file
      {:ok, report} = ElixirOntologies.Validator.validate(graph, shapes_file: "my-shapes.ttl")

      # Custom timeout
      {:ok, report} = ElixirOntologies.Validator.validate(graph, timeout: 60_000)

  """
  @spec validate(Graph.t(), [option()]) :: validation_result()
  def validate(%Graph{} = graph, opts \\ []) do
    with {:ok, turtle_string} <- serialize_graph(graph),
         {:ok, result} <- ShaclEngine.validate(turtle_string, opts) do
      process_validation_result(result)
    end
  end

  @doc """
  Checks if the SHACL validator (pySHACL) is available.

  ## Returns

  - `true` if pySHACL is installed and available
  - `false` otherwise

  ## Examples

      iex> if ElixirOntologies.Validator.available?() do
      ...>   IO.puts("Validation available")
      ...> else
      ...>   IO.puts("Please install pySHACL")
      ...> end

  """
  @spec available?() :: boolean()
  def available? do
    ShaclEngine.available?()
  end

  @doc """
  Returns installation instructions for pySHACL.

  ## Returns

  A string with installation instructions

  ## Examples

      iex> instructions = ElixirOntologies.Validator.installation_instructions()
      iex> IO.puts(instructions)

  """
  @spec installation_instructions() :: String.t()
  def installation_instructions do
    ShaclEngine.installation_instructions()
  end

  # Serializes graph to Turtle format
  @spec serialize_graph(Graph.t()) :: {:ok, String.t()} | {:error, term()}
  defp serialize_graph(graph) do
    case Graph.to_turtle(graph) do
      {:ok, turtle} -> {:ok, turtle}
      {:error, reason} -> {:error, {:serialization_error, reason}}
    end
  end

  # Processes the validation result from ShaclEngine
  @spec process_validation_result(ShaclEngine.validation_result()) :: validation_result()
  defp process_validation_result({:ok, :conforms}) do
    # Graph conforms - return empty report
    {:ok, Report.new(conforms: true)}
  end

  defp process_validation_result({:ok, :non_conformant, report_turtle}) do
    # Graph does not conform - parse the validation report
    case ReportParser.parse(report_turtle) do
      {:ok, report} ->
        {:ok, report}

      {:error, reason} ->
        Logger.warning("Failed to parse validation report: #{inspect(reason)}")
        # Return a basic non-conformant report
        {:ok, Report.new(conforms: false)}
    end
  end

  defp process_validation_result({:error, reason}) do
    {:error, reason}
  end
end
