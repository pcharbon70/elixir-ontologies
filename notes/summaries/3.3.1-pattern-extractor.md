# Summary: Task 3.3.1 - Pattern Extractor Module

## Overview

Implemented the Pattern extractor module that analyzes Elixir AST nodes representing patterns and extracts their type classification, bound variables, and structure. This covers all 11 pattern types defined in elixir-core.ttl plus guard clauses.

## Implementation

### Module: `ElixirOntologies.Extractors.Pattern`

Location: `lib/elixir_ontologies/extractors/pattern.ex`

### Result Struct

```elixir
%Pattern{
  type: :variable | :wildcard | :pin | :literal | :tuple | :list |
        :map | :struct | :binary | :as | :guard,
  value: term(),           # Pattern AST or extracted value
  bindings: [atom()],      # Variables bound by this pattern
  location: SourceLocation.t() | nil,
  metadata: %{
    # Type-specific metadata
    variable_name: atom(),     # For variable
    pinned_variable: atom(),   # For pin
    literal_type: atom(),      # For literal (:atom, :integer, :float, :string, :boolean, :nil)
    struct_name: [atom()] | :any, # For struct
    is_any_struct: boolean(),  # For struct (true for %_{})
    has_cons_cell: boolean(),  # For list
    has_specifiers: boolean(), # For binary
    guard_expression: Macro.t(), # For guard
    pattern: Macro.t(),        # For guard (the pattern before when)
    left_pattern: Macro.t(),   # For as pattern
    right_pattern: Macro.t(),  # For as pattern
    elements: list(),          # For tuple/list
    pairs: list(),             # For map/struct
    segments: list(),          # For binary
  }
}
```

### Supported Pattern Types (11 total)

| Type | Example | Ontology Class |
|------|---------|----------------|
| Variable | `x`, `name` | `core:VariablePattern` |
| Wildcard | `_` | `core:WildcardPattern` |
| Pin | `^x` | `core:PinPattern` |
| Literal | `:ok`, `42`, `"hello"` | `core:LiteralPattern` |
| Tuple | `{a, b}`, `{:ok, value}` | `core:TuplePattern` |
| List | `[a, b, c]`, `[h \| t]` | `core:ListPattern` |
| Map | `%{key: value}` | `core:MapPattern` |
| Struct | `%User{name: n}`, `%_{field: v}` | `core:StructPattern` |
| Binary | `<<a, b>>`, `<<x::binary>>` | `core:BinaryPattern` |
| As | `{:ok, _} = result` | `core:AsPattern` |
| Guard | `x when is_integer(x)` | `core:Guard` |

### Key Functions

- `pattern?/1` - Check if AST node is a pattern
- `pattern_type/1` - Get pattern type classification
- `extract/1` - Extract pattern with `{:ok, result}` / `{:error, reason}`
- `extract!/1` - Extract pattern, raising on error
- `collect_bindings/1` - Collect all variable bindings from patterns
- Type-specific extractors: `extract_variable/1`, `extract_wildcard/1`, `extract_pin/1`, `extract_literal/1`, `extract_tuple/1`, `extract_list/1`, `extract_map/1`, `extract_struct/1`, `extract_binary/1`, `extract_as/1`, `extract_guard/1`

### Key Features

1. **Variable Binding Collection**: Recursively collects all variables bound by a pattern, handling nested structures, cons cells, map values, and struct fields.

2. **Special Form Exclusion**: Excludes Elixir special forms (`def`, `defmodule`, `if`, etc.) from being detected as variable patterns.

3. **Cons Cell Detection**: Properly detects `[head | tail]` patterns and marks them with `has_cons_cell: true`.

4. **Anonymous Struct Support**: Detects `%_{field: value}` patterns and marks them with `is_any_struct: true`.

5. **Binary Specifier Detection**: Detects patterns with specifiers like `<<x::binary-size(4)>>`.

### Edge Cases Handled

1. **Deeply nested patterns**: Recursively extracts bindings from arbitrarily nested structures.

2. **Mixed pattern types**: Handles patterns containing multiple pattern types (e.g., map with list and tuple values).

3. **Special forms**: Properly excludes `def`, `defmodule`, `if`, `case`, etc. from being detected as variable patterns.

4. **Pin patterns**: Correctly identifies pinned variables and excludes them from bindings (they reference existing values, not new bindings).

5. **Wildcard patterns**: Correctly excludes wildcards (`_`) from bindings.

6. **As patterns**: Collects bindings from both sides of the `=` operator.

## Test Results

- **110 total tests** (30 doctests + 80 unit tests)
- All tests pass with no warnings
- Full test suite: **971 tests** (217 doctests + 754 tests), 0 failures

### Test Coverage by Category

| Category | Test Count |
|----------|------------|
| Variable pattern | 3 |
| Wildcard pattern | 2 |
| Pin pattern | 2 |
| Literal patterns | 6 |
| Tuple patterns | 5 |
| List patterns | 5 |
| Map patterns | 4 |
| Struct patterns | 4 |
| Binary patterns | 4 |
| As patterns | 3 |
| Guard patterns | 3 |
| Type detection | 13 |
| Main extraction | 4 |
| Binding collection | 7 |
| Edge cases | 4 |

## Files Created/Modified

### Created
- `lib/elixir_ontologies/extractors/pattern.ex` - Main module (~800 lines)
- `test/elixir_ontologies/extractors/pattern_test.exs` - Test file (~740 lines)
- `notes/features/3.3.1-pattern-extractor.md` - Planning document
- `notes/summaries/3.3.1-pattern-extractor.md` - This summary

### Modified
- `notes/planning/phase-03.md` - Marked task 3.3.1 as complete

## Design Decisions

1. **Binding Collection**: Implemented as a separate function (`collect_bindings/1`) that recursively traverses pattern AST nodes to extract all bound variable names.

2. **Special Forms List**: Extensive list of Elixir special forms to prevent false positives when detecting variable patterns.

3. **Metadata Structure**: Each pattern type has its own metadata fields relevant to that type, avoiding a one-size-fits-all approach.

4. **Location Extraction**: Reuses the existing `Location.extract_range/1` function for consistent location handling.

5. **Cons Cell Detection**: Uses pattern matching on `{:|, _, _}` to detect cons cells in list patterns.

## Integration with Ontology

The module aligns with elixir-core.ttl classes:
- `core:Pattern` (parent class)
- `core:VariablePattern`, `core:WildcardPattern`, `core:PinPattern`, etc. (type classes)

Properties:
- `core:bindsVariable` - Variables bound by the pattern
- `core:pinsVariable` - Variable referenced by pin pattern
- `core:hasPattern` - Nested patterns in compound patterns

## Next Steps

- Task 3.4.1: Control Flow Extractor Module (if, unless, case, cond, with, try, receive)
