# Summary: Task 4.1.1 - Module Extractor Module

## Overview

Implemented a comprehensive Module extractor for Phase 4 that extracts Elixir module definitions from AST, including module name, nested modules, documentation, and directives.

## Files Created

### `lib/elixir_ontologies/extractors/module.ex` (~780 lines)

Main extractor module with:

**Result Struct:**
```elixir
%Module{
  type: :module | :nested_module,
  name: [atom()],  # e.g., [:MyApp, :Users]
  docstring: String.t() | false | nil,
  aliases: [%{module: [atom()] | atom(), as: atom() | nil}],
  imports: [%{module: [atom()] | atom(), only: keyword() | nil, except: keyword() | nil}],
  requires: [%{module: [atom()] | atom(), as: atom() | nil}],
  uses: [%{module: [atom()] | atom(), opts: keyword()}],
  functions: [%{name: atom(), arity: non_neg_integer(), visibility: :public | :private}],
  macros: [%{name: atom(), arity: non_neg_integer(), visibility: :public | :private}],
  types: [%{name: atom(), arity: non_neg_integer(), visibility: :public | :private | :opaque}],
  location: SourceLocation.t() | nil,
  metadata: %{parent_module: [atom()] | nil, has_moduledoc: boolean(), nested_modules: [[atom()]]}
}
```

**Public API:**
- `module?/1` - Type detection for module AST nodes
- `extract/2` - Main extraction with `parent_module` option for nested modules
- `extract!/2` - Raising variant
- `module_name_string/1` - Returns "MyApp.Users" format
- `module_name_atom/1` - Returns `MyApp.Users` module atom
- `has_docs?/1` - Checks for string moduledoc
- `docs_hidden?/1` - Checks for `@moduledoc false`

**Extraction Capabilities:**
- Module names (single and multi-segment)
- Nested module detection with parent tracking
- `@moduledoc` (string, heredoc, `false`)
- `alias` directives with `:as` option
- `import` directives with `:only`/`:except` options
- `require` directives with `:as` option
- `use` directives with options
- Functions (`def`/`defp`) with name, arity, visibility
- Macros (`defmacro`/`defmacrop`) with name, arity, visibility
- Types (`@type`/`@typep`/`@opaque`) with name, arity, visibility

### `test/elixir_ontologies/extractors/module_test.exs` (~627 lines)

Comprehensive test coverage:
- Type detection tests (`module?/1`)
- Basic module extraction tests
- Nested module detection tests
- `@moduledoc` extraction tests (string, heredoc, false)
- Alias extraction tests (simple, with `:as`, multiple)
- Import extraction tests (simple, `:only`, `:except`, erlang modules)
- Require extraction tests (simple, with `:as`)
- Use extraction tests (simple, with options)
- Function extraction tests (public, private, guards, multi-clause, different arities)
- Macro extraction tests (public, private)
- Type extraction tests (public, private, opaque, parameterized)
- Convenience function tests
- `extract!/2` tests
- Complex module integration tests

## Key Implementation Details

1. **AST Argument Handling:** In Elixir AST, function/macro arguments can be a list or an atom (context) when no arguments. Added `args_length/1` helper to handle both cases correctly.

2. **Moduledoc False Detection:** Used `Enum.reduce_while/3` instead of `Enum.find_value/2` since the latter treats `false` as "not found."

3. **Body Extraction:** Handle various module body formats including `[do: body]`, `[{:do, body} | _rest]`, and keyword lists.

4. **Erlang Module Support:** Properly handle Erlang module atoms (e.g., `:lists`) in import directives.

5. **Deduplication:** Multi-clause functions/macros are deduplicated by `{name, arity}` to return single entries.

## Test Results

- **Total Tests:** 61 (14 doctests + 47 unit tests)
- **Failures:** 0
- **Dialyzer:** Passes with 0 errors
- **Full Suite:** 1496 tests (377 doctests + 23 properties + 1096 tests), 0 failures

## Ontology Alignment

Supports the following from `elixir-structure.ttl`:
- `Module` - Main module class with `moduleName`
- `NestedModule` - Module defined inside another (has `parentModule`)
- `ModuleAlias` - `alias` directive
- `Import` - `import` directive with `:only`/`:except`
- `Require` - `require` directive
- `Use` - `use` directive

## Next Steps

Task 4.1.2 - Module Attribute Extractor:
- Extract generic `ModuleAttribute` with `attributeName`, `attributeValue`
- Classify `@doc`, `@moduledoc`, `@typedoc` as DocAttribute subtypes
- Extract `@deprecated` as `DeprecatedAttribute` with message
- Extract `@since` as `SinceAttribute` with version
- Extract `@external_resource`, `@compile`, `@behaviour`
