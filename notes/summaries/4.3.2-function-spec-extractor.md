# Summary: Task 4.3.2 - Function Spec Extractor

## Overview

Implemented a Function Spec extractor for Phase 4 that extracts @spec definitions from AST, including function name, arity, parameter types, return type, and `when` clause type constraints.

## Files Created

### `lib/elixir_ontologies/extractors/function_spec.ex` (~220 lines)

Main extractor module with:

**Result Struct:**
```elixir
%FunctionSpec{
  name: atom(),
  arity: non_neg_integer(),
  parameter_types: [Macro.t()],
  return_type: Macro.t(),
  type_constraints: %{atom() => Macro.t()},
  location: SourceLocation.t() | nil,
  metadata: %{
    has_when_clause: boolean()
  }
}
```

**Public API:**
- `spec?/1` - Type detection for @spec attributes
- `extract/2` - Main extraction from @spec AST
- `extract!/2` - Raising variant
- `extract_all/1` - Bulk extraction from module body
- `has_when_clause?/1` - Check if spec has type constraints
- `spec_id/1` - Returns "name/arity" string
- `union_return?/1` - Check if return type is a union
- `flatten_union_return/1` - Flatten union type to list

**Features:**
- Extracts function name and arity from spec
- Extracts ordered parameter type list
- Extracts return type expression
- Handles `when` clauses with type variable constraints
- Handles union types in parameters and return
- Preserves type AST for further parsing by Type Expression Parser (task 4.3.3)

### `test/elixir_ontologies/extractors/function_spec_test.exs` (~430 lines)

Comprehensive test coverage:
- Spec detection tests
- Simple spec extraction tests
- Union type extraction tests
- When clause extraction tests
- Bulk extraction tests
- Helper function tests
- Error handling tests
- Integration tests with `quote`

## Key Implementation Details

1. **Two AST Patterns:** Specs come in two forms - with and without `when` clauses. The extractor handles both patterns.

2. **Type Constraints:** `when` clauses are extracted as a map of type variable to type expression, e.g., `%{a: {:var, [], nil}}`.

3. **Union Types:** The `union_return?/1` and `flatten_union_return/1` helpers provide utilities for working with union return types.

4. **Expression Preservation:** Both parameter types and return type are preserved as-is for further parsing by the Type Expression Parser (task 4.3.3).

5. **Bulk Extraction:** The `extract_all/1` function filters @spec attributes from module bodies.

## Test Results

- **Total Tests:** 62 (19 doctests + 43 unit tests)
- **Failures:** 0
- **Dialyzer:** Passes with 0 errors
- **Full Suite:** 2029 tests (544 doctests + 23 properties + 1462 tests), 0 failures

## Ontology Alignment

Supports the following from `elixir-structure.ttl`:
- `FunctionSpec` - Type specification for a function
- `hasSpec` - Links function to spec
- `hasParameterTypes` - Ordered list of parameter types (rdf:List)
- `hasReturnType` - The return type expression

## Relationship to Other Extractors

This continues Section 4.3 - Type Spec Extractor:
- **4.3.1 Type Definition Extractor** - Extracts @type/@typep/@opaque (completed)
- **4.3.2 Function Spec Extractor** - Extracts @spec definitions (this task)
- **4.3.3 Type Expression Parser** - Parses type expression structure (next)

## Next Steps

Task 4.3.3 - Type Expression Parser:
- Parse `BasicType` (atom(), integer(), binary(), etc.)
- Parse `UnionType` (type1 | type2)
- Parse `TupleType` ({type1, type2})
- Parse `ListType` ([type])
- Parse `MapType` (%{key => value})
- Parse `FunctionType` ((args -> return))
- Parse `ParameterizedType` (Enumerable.t(element))
- Handle remote types (Module.type())
