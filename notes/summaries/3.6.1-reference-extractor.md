# Summary: Task 3.6.1 - Reference Extractor Module

## Overview

Implemented the Reference extractor module that analyzes Elixir AST nodes representing variables, module references, function captures, and function calls.

## Implementation

### Module: `ElixirOntologies.Extractors.Reference`

Location: `lib/elixir_ontologies/extractors/reference.ex`

### Result Struct

```elixir
%Reference{
  type: :variable | :module | :function_capture | :remote_call | :local_call | :binding | :pin,
  name: atom() | [atom()] | nil,
  module: [atom()] | atom() | nil,
  function: atom() | nil,
  arity: non_neg_integer() | nil,
  arguments: [Macro.t()] | nil,
  value: Macro.t() | nil,
  location: SourceLocation.t() | nil,
  metadata: map()
}
```

### Supported Reference Types

| Type | AST Form | Description |
|------|----------|-------------|
| Variable | `{:name, meta, context}` | Simple variable reference |
| Module | `{:__aliases__, meta, segments}` | Module alias reference |
| Function Capture | `{:&, meta, [body]}` | Captured function reference |
| Remote Call | `{{:., meta, [mod, fun]}, meta, args}` | Module.function(args) |
| Local Call | `{:name, meta, args}` | function(args) |
| Binding | `{:=, meta, [pattern, value]}` | Variable assignment |
| Pin | `{:^, meta, [var]}` | Pinned variable |

### Key Functions

#### Type Detection
- `variable?/1` - Check if AST is a variable
- `module_reference?/1` - Check if AST is a module alias
- `function_capture?/1` - Check if AST is a function capture
- `remote_call?/1` - Check if AST is a remote call
- `local_call?/1` - Check if AST is a local function call
- `binding?/1` - Check if AST is a binding expression
- `pin?/1` - Check if AST is a pin expression
- `reference_type/1` - Returns the reference type atom or nil

#### Extraction
- `extract/1` - Extract with `{:ok, result}` / `{:error, reason}`
- `extract!/1` - Extract, raising on error
- `extract_variable/1` - Extract variable specifically
- `extract_module/1` - Extract module reference specifically
- `extract_function_capture/1` - Extract function capture specifically
- `extract_remote_call/1` - Extract remote call specifically
- `extract_local_call/1` - Extract local call specifically
- `extract_binding/1` - Extract binding specifically
- `extract_pin/1` - Extract pin specifically

#### Convenience
- `remote?/1` - Check if reference involves a remote module
- `call?/1` - Check if reference is a function call
- `module_string/1` - Get module as a string

### Key Features

1. **Variable Detection**: Distinguishes variables from special forms and underscore-prefixed ignored variables.

2. **Function Capture Classification**: Identifies three capture types:
   - `:local` - Local function capture (`&my_func/2`)
   - `:remote` - Remote function capture (`&String.upcase/1`)
   - `:anonymous` - Anonymous capture (`&(&1 + 1)`)

3. **Erlang Module Support**: Handles erlang module calls (`:erlang.now()`) with `is_erlang` metadata.

4. **Nested Modules**: Tracks module nesting depth and provides full module name string.

5. **Binding Patterns**: Extracts both simple and complex patterns from binding expressions.

### Metadata Fields by Type

| Type | Metadata Fields |
|------|-----------------|
| Variable | `context` |
| Module | `full_name`, `depth` |
| Function Capture | `capture_type`, `is_remote` |
| Remote Call | `full_call`, `is_erlang` |
| Local Call | `full_call` |
| Binding | `pattern` (for complex patterns) |
| Pin | `pinned_variable` |

## Test Results

- **104 total tests** (43 doctests + 61 unit tests)
- All tests pass with no warnings
- Full test suite: **1333 tests** (353 doctests + 980 tests), 0 failures

### Test Coverage by Category

| Category | Test Count |
|----------|------------|
| Type detection (variable?, module_reference?, etc.) | 21 |
| Variable extraction | 2 |
| Module reference extraction | 2 |
| Function capture extraction | 5 |
| Remote call extraction | 4 |
| Local call extraction | 2 |
| Binding extraction | 3 |
| Pin extraction | 1 |
| Convenience functions (remote?, call?, module_string) | 8 |
| Error handling | 3 |
| Edge cases | 4 |

## Files Created/Modified

### Created
- `lib/elixir_ontologies/extractors/reference.ex` - Main module (~350 lines)
- `test/elixir_ontologies/extractors/reference_test.exs` - Test file (~500 lines)
- `notes/features/3.6.1-reference-extractor.md` - Planning document
- `notes/summaries/3.6.1-reference-extractor.md` - This summary

### Modified
- `notes/planning/phase-03.md` - Marked task 3.6.1 as complete

## Design Decisions

1. **Special Forms List**: Maintains a comprehensive list of special forms to exclude from variable/local call detection.

2. **Underscore Variables**: Variables starting with `_` are excluded from variable detection as they represent intentionally ignored values.

3. **Erlang vs Elixir Modules**: Distinguishes between atom modules (`:erlang`) and alias modules (`[:String]`) for proper handling.

4. **Capture Type Detection**: Uses AST structure to determine capture type rather than requiring explicit annotation.

5. **Full Call String**: Provides `full_call` metadata for easy logging and debugging (e.g., "String.upcase/1").

## Integration with Ontology

The module aligns with elixir-core.ttl classes:
- `core:Variable` - Variable reference
- `core:ModuleReference` - Module alias
- `core:FunctionCapture` - Captured function
- `core:RemoteCall` - Module function call
- `core:LocalCall` - Local function call
- `core:Binding` - Variable binding
- `core:Pin` - Pinned variable

Properties:
- `core:refersToModule` - Module referenced
- `core:refersToFunction` - Function referenced
- `core:hasArity` - Function arity
- `core:hasArgument` - Call arguments
- `core:bindsVariable` - Variable bound in binding
- `core:pinsVariable` - Variable pinned in pin expression

## Next Steps

- Phase 3 Integration Tests (test extraction across all core extractors)
- Phase 4: Structure Extractors (modules, functions, protocols, behaviours)
