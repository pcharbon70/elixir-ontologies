# Summary: Task 3.4.1 - Control Flow Extractor Module

## Overview

Implemented the Control Flow extractor module that analyzes Elixir AST nodes representing control flow expressions and extracts their type classification, conditions, clauses, branches, and metadata. This covers all 9 control flow types defined in elixir-core.ttl.

## Implementation

### Module: `ElixirOntologies.Extractors.ControlFlow`

Location: `lib/elixir_ontologies/extractors/control_flow.ex`

### Result Struct

```elixir
%ControlFlow{
  type: :if | :unless | :case | :cond | :with | :try | :receive | :raise | :throw,
  condition: Macro.t() | nil,     # For if/unless/case
  clauses: [clause()],            # For case/cond/with/try/receive
  branches: %{
    then: Macro.t() | nil,        # For if/unless
    else: Macro.t() | nil,        # For if/unless/with
    do: Macro.t() | nil,          # General body
    rescue: [clause()],           # For try
    catch: [clause()],            # For try
    after: Macro.t() | nil,       # For try/receive
  },
  location: SourceLocation.t() | nil,
  metadata: map()
}
```

### Clause Structure

```elixir
%{
  patterns: [Macro.t()],  # Pattern ASTs for matching
  guard: Macro.t() | nil, # Optional guard expression
  body: Macro.t()         # Clause body
}
```

### Supported Control Flow Types (9 total)

| Type | Example | Ontology Class |
|------|---------|----------------|
| If | `if cond, do: then, else: else_` | `core:IfExpression` |
| Unless | `unless cond, do: body` | `core:UnlessExpression` |
| Case | `case val do pattern -> body end` | `core:CaseExpression` |
| Cond | `cond do cond -> body end` | `core:CondExpression` |
| With | `with {:ok, x} <- f() do ... end` | `core:WithExpression` |
| Try | `try do ... rescue/catch/after ... end` | `core:TryExpression` |
| Receive | `receive do pattern -> body after t -> fallback end` | `core:ReceiveExpression` |
| Raise | `raise "error"`, `raise ExceptionMod, opts` | `core:RaiseExpression` |
| Throw | `throw value` | `core:ThrowExpression` |

### Key Functions

- `control_flow?/1` - Check if AST node is a control flow expression
- `control_flow_type/1` - Get control flow type classification
- `extract/1` - Extract control flow with `{:ok, result}` / `{:error, reason}`
- `extract!/1` - Extract control flow, raising on error
- `extract_clauses/1` - Extract clauses from arrow expressions
- Type-specific extractors: `extract_if/1`, `extract_unless/1`, `extract_case/1`, `extract_cond/1`, `extract_with/1`, `extract_try/1`, `extract_receive/1`, `extract_raise/1`, `extract_throw/1`

### Key Features

1. **Clause Extraction**: Extracts patterns, guards, and bodies from arrow expressions (`->`), including support for guards with `when` clauses.

2. **Branch Handling**: Handles optional branches (else, rescue, catch, after) gracefully, with metadata indicating their presence.

3. **With Match Clauses**: Properly parses `<-` match clauses in `with` expressions, separating them from the final options.

4. **Try Multi-Clause Support**: Handles rescue, catch, and after clauses independently, each with multiple sub-clauses.

5. **Receive Timeout**: Extracts timeout value and body from `after` clause in receive expressions.

6. **Raise Classification**: Distinguishes between string message raises, exception module raises, and reraises.

### Metadata Fields by Type

| Type | Metadata Fields |
|------|-----------------|
| If/Unless | `has_else` |
| Case | `clause_count` |
| Cond | `clause_count` |
| With | `has_else`, `match_clause_count`, `else_clause_count` |
| Try | `has_rescue`, `has_catch`, `has_after`, `rescue_clause_count`, `catch_clause_count` |
| Receive | `has_timeout`, `timeout_value`, `clause_count` |
| Raise | `raise_type`, `message`, `exception_module`, `options`, `exception` |
| Throw | `thrown_value` |

## Test Results

- **92 total tests** (27 doctests + 65 unit tests)
- All tests pass with no warnings
- Full test suite: **1036 tests** (217 doctests + 819 tests), 0 failures

### Test Coverage by Category

| Category | Test Count |
|----------|------------|
| Type detection (control_flow?) | 10 |
| Type classification (control_flow_type) | 10 |
| If expression | 4 |
| Unless expression | 2 |
| Case expression | 4 |
| Cond expression | 3 |
| With expression | 4 |
| Try expression | 5 |
| Receive expression | 4 |
| Raise expression | 5 |
| Throw expression | 3 |
| Main extraction | 4 |
| Clause extraction | 3 |
| Edge cases | 4 |

## Files Created/Modified

### Created
- `lib/elixir_ontologies/extractors/control_flow.ex` - Main module (~500 lines)
- `test/elixir_ontologies/extractors/control_flow_test.exs` - Test file (~630 lines)
- `notes/features/3.4.1-control-flow-extractor.md` - Planning document
- `notes/summaries/3.4.1-control-flow-extractor.md` - This summary

### Modified
- `notes/planning/phase-03.md` - Marked task 3.4.1 as complete

## Design Decisions

1. **Unified Clause Structure**: All clause-based control flow (case, cond, with, try, receive) use the same clause structure with patterns, guard, and body.

2. **Guard Extraction**: Guards are extracted from `when` clauses and combined with `and` for multiple guard expressions.

3. **Branches Map**: Uses a branches map to store different branch types (then, else, do, rescue, catch, after) in a consistent structure.

4. **Metadata Enrichment**: Each control flow type has specific metadata fields relevant to that type.

5. **Raise Classification**: Distinguishes between `:message` (string), `:exception` (module), and `:reraise` (variable) types.

## Integration with Ontology

The module aligns with elixir-core.ttl classes:
- `core:ControlFlowExpression` (parent class)
- `core:IfExpression`, `core:UnlessExpression`, `core:CaseExpression`, etc. (type classes)

Properties:
- `core:hasCondition` - Condition expression for if/unless/case
- `core:hasThenBranch` - Then branch for if/unless
- `core:hasElseBranch` - Else branch for if/unless/with
- `core:hasClause` - Clauses for case/cond/receive
- `core:hasRescueClause`, `core:hasCatchClause`, `core:hasAfterClause` - Try clauses

## Next Steps

- Task 3.5.1: Comprehension Extractor (for, generators, filters, into)
