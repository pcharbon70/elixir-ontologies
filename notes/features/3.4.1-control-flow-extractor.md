# Feature 3.4.1: Control Flow Extractor Module

## Overview

Create extractors for all control flow expression types defined in elixir-core.ttl. Control flow expressions govern program execution flow through conditionals, pattern matching, exception handling, and message receiving.

## AST Analysis

### Control Flow Types and AST Representations

| Expression | Example | AST Form |
|------------|---------|----------|
| If | `if x > 0, do: :pos, else: :neg` | `{:if, meta, [condition, [do: then, else: else_branch]]}` |
| Unless | `unless x == 0, do: :ok` | `{:unless, meta, [condition, [do: body, else: else_branch]]}` |
| Case | `case val do ... end` | `{:case, meta, [value, [do: clauses]]}` |
| Cond | `cond do ... end` | `{:cond, meta, [[do: clauses]]}` |
| With | `with {:ok, x} <- f() do ... end` | `{:with, meta, [match_clauses..., [do: body, else: else_clauses]]}` |
| Try | `try do ... rescue ... end` | `{:try, meta, [[do: body, rescue: clauses, catch: clauses, after: after_body]]}` |
| Receive | `receive do ... after ... end` | `{:receive, meta, [[do: clauses, after: timeout_clauses]]}` |
| Raise | `raise "error"` | `{:raise, meta, [message_or_exception]}` |
| Throw | `throw {:error, val}` | `{:throw, meta, [value]}` |

### Detailed AST Patterns

#### If/Unless Expression
```elixir
# if x > 0, do: :positive, else: :negative
{:if, [line: 1],
 [
   {:>, [line: 1], [{:x, [line: 1], nil}, 0]},
   [do: :positive, else: :negative]
 ]}

# if without else
{:if, [line: 1], [{:>, [line: 1], [{:x, [line: 1], nil}, 0]}, [do: :positive]]}
```

#### Case Expression
```elixir
# case value do {:ok, result} -> result end
{:case, [line: 1],
 [
   {:value, [line: 1], nil},
   [
     do: [
       {:->, [line: 2], [[ok: {:result, [], nil}], {:result, [], nil}]}
     ]
   ]
 ]}
```

#### Cond Expression
```elixir
# cond do x > 0 -> :positive; true -> :zero end
{:cond, [line: 1],
 [
   [
     do: [
       {:->, [line: 2], [[{:>, [], [{:x, [], nil}, 0]}], :positive]},
       {:->, [line: 3], [[true], :zero]}
     ]
   ]
 ]}
```

#### With Expression
```elixir
# with {:ok, a} <- get_a(), {:ok, b} <- get_b(a) do ... else ... end
{:with, [line: 1],
 [
   {:<-, [line: 1], [{:ok, {:a, [], nil}}, {:get_a, [], []}]},
   {:<-, [line: 2], [{:ok, {:b, [], nil}}, {:get_b, [], [{:a, [], nil}]}]},
   [
     do: {:ok, {:+, [], [{:a, [], nil}, {:b, [], nil}]}},
     else: [{:->, [], [[error: {:reason, [], nil}], {:error, {:reason, [], nil}}]}]
   ]
 ]}
```

#### Try Expression
```elixir
# try do ... rescue ... catch ... after ... end
{:try, [line: 1],
 [
   [
     do: {:risky_operation, [], []},
     rescue: [{:->, [], [[{:in, [], [{:e, [], nil}, {:__aliases__, [], [:RuntimeError]}]}], ...]}],
     catch: [{:->, [], [[:exit, {:reason, [], nil}], {:exit, {:reason, [], nil}}]}],
     after: {:cleanup, [], []}
   ]
 ]}
```

#### Receive Expression
```elixir
# receive do {:ok, msg} -> msg after 5000 -> :timeout end
{:receive, [line: 1],
 [
   [
     do: [{:->, [], [[ok: {:msg, [], nil}], {:msg, [], nil}]}],
     after: [{:->, [], [[5000], :timeout]}]
   ]
 ]}
```

#### Raise/Throw Expressions
```elixir
# raise "error message"
{:raise, [line: 1], ["error message"]}

# raise RuntimeError, message: "error"
{:raise, [line: 1], [{:__aliases__, [], [:RuntimeError]}, [message: "error"]]}

# throw {:error, :not_found}
{:throw, [line: 1], [error: :not_found]}
```

### Edge Cases

1. **If without else**: The else branch is `nil`
2. **Case with guards**: Clauses can have `when` guards
3. **Try with only rescue**: catch and after are optional
4. **With without else**: Returns the non-matching value directly
5. **Receive without after**: No timeout clause
6. **Raise with module**: Can raise specific exception types
7. **Multi-clause try blocks**: Each rescue/catch can have multiple clauses

## Implementation Plan

### Module Structure

```elixir
defmodule ElixirOntologies.Extractors.ControlFlow do
  @moduledoc """
  Extracts control flow expressions from AST nodes.
  """

  defstruct [:type, :condition, :clauses, :branches, :location, :metadata]

  # Main dispatch
  def extract(node)
  def extract!(node)

  # Type detection
  def control_flow?(node)
  def control_flow_type(node)

  # Type-specific extractors
  def extract_if(node)
  def extract_unless(node)
  def extract_case(node)
  def extract_cond(node)
  def extract_with(node)
  def extract_try(node)
  def extract_receive(node)
  def extract_raise(node)
  def extract_throw(node)
end
```

### Result Struct

```elixir
%ControlFlow{
  type: :if | :unless | :case | :cond | :with | :try | :receive | :raise | :throw,
  condition: Macro.t() | nil,     # For if/unless/case
  clauses: [clause()],            # For case/cond/with/try/receive
  branches: %{
    then: Macro.t() | nil,        # For if/unless
    else: Macro.t() | nil,        # For if/unless/with
    do: Macro.t() | nil,          # General body
    rescue: [clause()],           # For try
    catch: [clause()],            # For try
    after: Macro.t() | nil,       # For try/receive
  },
  location: SourceLocation.t() | nil,
  metadata: %{
    has_else: boolean(),          # For if/unless/with
    clause_count: integer(),      # For case/cond
    has_timeout: boolean(),       # For receive
    exception_type: atom() | nil, # For raise
  }
}
```

### Clause Struct

```elixir
%Clause{
  patterns: [Macro.t()],
  guard: Macro.t() | nil,
  body: Macro.t()
}
```

### Ontology Mapping

| Expression Type | Ontology Class | Key Properties |
|-----------------|----------------|----------------|
| `:if` | `core:IfExpression` | `hasCondition`, `hasThenBranch`, `hasElseBranch` |
| `:unless` | `core:UnlessExpression` | `hasCondition`, `hasThenBranch`, `hasElseBranch` |
| `:case` | `core:CaseExpression` | `hasClause` |
| `:cond` | `core:CondExpression` | `hasClause` |
| `:with` | `core:WithExpression` | `hasClause`, `hasElseBranch` |
| `:try` | `core:TryExpression` | `hasRescueClause`, `hasCatchClause`, `hasAfterClause` |
| `:receive` | `core:ReceiveExpression` | `hasClause`, `hasTimeout` |
| `:raise` | `core:RaiseExpression` | exception info |
| `:throw` | `core:ThrowExpression` | thrown value |

## Test Plan

### Test Cases (50+ tests)

1. **If expression**: with/without else, nested conditions
2. **Unless expression**: with/without else
3. **Case expression**: simple, multiple clauses, with guards
4. **Cond expression**: multiple conditions, default clause
5. **With expression**: single/multiple match clauses, with/without else
6. **Try expression**: rescue only, catch only, after only, all three
7. **Receive expression**: with/without timeout
8. **Raise expression**: string message, exception module, with options
9. **Throw expression**: various thrown values
10. **Type detection**: `control_flow?/1`, `control_flow_type/1`
11. **Clause extraction**: pattern extraction, guard detection
12. **Error handling**: non-control-flow nodes
13. **Location extraction**: when metadata present

## Files to Create/Modify

- Create: `lib/elixir_ontologies/extractors/control_flow.ex`
- Create: `test/elixir_ontologies/extractors/control_flow_test.exs`

## Dependencies

- `ElixirOntologies.Analyzer.Location` for source location extraction
- `ElixirOntologies.Extractors.Pattern` for clause pattern extraction
