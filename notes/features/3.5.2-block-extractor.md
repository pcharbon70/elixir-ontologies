# Feature: 3.5.2 Block Extractor Module

## Overview

Implement the Block extractor module that analyzes Elixir AST nodes representing block structures and extracts their contained expressions with ordering information.

## AST Structure Analysis

Based on exploration of Elixir's block AST:

```elixir
# __block__ - Multiple expressions
{:__block__, [], [
  {:=, [], [{:x, [], Elixir}, 1]},  # expr 1
  {:=, [], [{:y, [], Elixir}, 2]},  # expr 2
  {:+, [], [{:x, [], Elixir}, {:y, [], Elixir}]}  # expr 3 (return value)
]}

# Single expression - NOT wrapped in __block__
{:=, [], [{:x, [], Elixir}, 1]}

# fn...end - Anonymous function
{:fn, [], [
  {:->, [], [[param_pattern], body]},    # clause 1
  {:->, [], [[param_pattern], body]}     # clause 2 (optional)
]}

# fn with guards
{:fn, [], [
  {:->, [], [
    [{:when, [], [param, guard_expr]}],  # pattern with guard
    body
  ]}
]}
```

## Block Types to Extract

1. **Block (`__block__`)** - Sequence of expressions
2. **Anonymous Function (`fn`)** - Function with clauses
3. **Do Block** - Not a separate AST form, but `__block__` inside `:do` keyword

## Implementation Plan

### 1. Create Module Structure

- [x] 3.5.2.1 Create `lib/elixir_ontologies/extractors/block.ex`
- [x] Define result structs for Block and AnonymousFunction
- [x] Use shared Helpers module for location extraction

### 2. Block Extraction

- [x] 3.5.2.2 Extract `Block` with contained expressions
- [x] 3.5.2.3 Extract `DoBlock` from do...end syntax (via __block__)
- [x] 3.5.2.5 Add `containsExpression` relationships
- [x] 3.5.2.6 Add `expressionOrder` for each contained expression

### 3. Anonymous Function Extraction

- [x] 3.5.2.4 Extract `FnBlock` from fn...end syntax
- [x] Extract clauses with patterns, guards, and bodies
- [x] Handle single and multi-clause functions

### 4. Testing

- [x] 3.5.2.7 Write block tests

## Result Struct Design

```elixir
# For __block__ expressions
%Block{
  type: :block,
  expressions: [indexed_expression()],
  location: SourceLocation.t() | nil,
  metadata: %{
    expression_count: non_neg_integer(),
    has_return_value: boolean()
  }
}

# Indexed expression with order
%{
  index: non_neg_integer(),  # 0-based position
  expression: Macro.t(),
  is_last: boolean()  # true if this is the return value
}

# For fn...end expressions
%AnonymousFunction{
  type: :fn,
  clauses: [fn_clause()],
  location: SourceLocation.t() | nil,
  metadata: %{
    clause_count: non_neg_integer(),
    arity: non_neg_integer() | :variable
  }
}

# Function clause
%{
  patterns: [Macro.t()],
  guard: Macro.t() | nil,
  body: Macro.t()
}
```

## Test Cases

1. Simple block with multiple expressions
2. Single expression (not a block)
3. Block with nested blocks
4. Anonymous function with single clause
5. Anonymous function with multiple clauses
6. Anonymous function with guards
7. Empty block edge case
8. Expression ordering verification

## Files to Create/Modify

### Create
- `lib/elixir_ontologies/extractors/block.ex`
- `test/elixir_ontologies/extractors/block_test.exs`

### Modify
- `notes/planning/phase-03.md` - Mark task complete

## Success Criteria

- [ ] All 7 subtasks implemented
- [ ] All tests pass
- [ ] No compilation warnings
- [ ] Doctests included for main functions
- [ ] Full test suite passes

## Status

- **Current Step:** Creating planning document
- **Next Step:** Implement module structure
