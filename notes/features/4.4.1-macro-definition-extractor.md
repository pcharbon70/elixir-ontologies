# Feature: Task 4.4.1 - Macro Definition Extractor

## Overview

Create a macro definition extractor that extracts defmacro and defmacrop definitions from AST, including macro name, arity, visibility, clauses, and hygiene detection.

## Problem Statement

Elixir macros come in two visibility levels:
1. `defmacro` - Public macros
2. `defmacrop` - Private macros

Each macro has:
- A macro name and arity
- One or more clauses (like functions)
- Optional guards
- A body containing quote/unquote expressions
- Hygiene settings (var!, Macro.escape)

The extractor needs to:
1. Detect macro definition forms
2. Extract macro name and arity
3. Determine visibility (public/private)
4. Extract macro clauses similar to functions
5. Detect hygiene violations (var!, Macro.escape)

## Ontology Classes to Support

From `elixir-structure.ttl`:
- `Macro` - Base class for macro definitions
- `PublicMacro`, `PrivateMacro` - Visibility subclasses
- `macroName`, `macroArity` properties
- `isHygienic` property for hygiene detection
- `MacroClause` - Individual macro clauses

## AST Patterns Reference

| Pattern | Example | AST Structure |
|---------|---------|---------------|
| defmacro | `defmacro foo(x)` | `{:defmacro, meta, [{:foo, _, [x]}, [do: body]]}` |
| defmacrop | `defmacrop bar(x)` | `{:defmacrop, meta, [{:bar, _, [x]}, [do: body]]}` |
| With guard | `defmacro foo(x) when is_atom(x)` | `{:defmacro, meta, [{:when, _, [call, guard]}, [do: body]]}` |
| var! | `var!(x)` | `{:var!, meta, [{:x, _, _}]}` |
| Macro.escape | `Macro.escape(v)` | `{{:., _, [{:__aliases__, _, [:Macro]}, :escape]}, _, [v]}` |

## Implementation Plan

### Step 1: Create Macro Extractor Module
- [x] Create `lib/elixir_ontologies/extractors/macro.ex`
- [x] Define `MacroDefinition` result struct
- [x] Add macro detection: `macro?/1`

### Step 2: Implement MacroDefinition.extract/2
- [x] Accept defmacro/defmacrop AST and optional context
- [x] Return `{:ok, %MacroDefinition{}}` or `{:error, reason}`
- [x] Add `extract!/2` that raises on error

### Step 3: Extract Macro Identity
- [x] Extract macro name from definition
- [x] Calculate arity from parameter count
- [x] Determine visibility from defmacro/defmacrop

### Step 4: Extract Macro Clauses
- [x] Extract clause with head and body
- [x] Handle guards in macro head
- [x] Support multiple clauses

### Step 5: Detect Hygiene Settings
- [x] Scan body for `var!` calls (unhygienic)
- [x] Scan body for `Macro.escape` calls
- [x] Set `is_hygienic` based on findings

### Step 6: Bulk Extraction
- [x] Add `extract_all/1` for module body
- [x] Filter macro definitions
- [x] Return list of MacroDefinition structs

### Step 7: Write Tests
- [x] Test defmacro extraction
- [x] Test defmacrop extraction
- [x] Test macro with guards
- [x] Test hygiene detection
- [x] Test multiple clauses

## Result Struct Design

```elixir
%MacroDefinition{
  name: atom(),
  arity: non_neg_integer(),
  visibility: :public | :private,
  parameters: [Macro.t()],
  guard: Macro.t() | nil,
  body: Macro.t(),
  is_hygienic: boolean(),
  location: SourceLocation.t() | nil,
  metadata: %{
    has_guard: boolean(),
    uses_var_bang: boolean(),
    uses_macro_escape: boolean()
  }
}
```

## Success Criteria

- [x] All 8 subtasks from plan completed
- [x] At least 10 tests passing (as specified in plan) - 58 tests (18 doctests + 40 unit tests)
- [x] Doctests for all public functions
- [x] Dialyzer passes with no errors
- [x] Consistent with other extractor patterns

## Files to Create/Modify

### Create
- `lib/elixir_ontologies/extractors/macro.ex` - Main extractor
- `test/elixir_ontologies/extractors/macro_test.exs` - Test file

### Modify
- `notes/planning/phase-04.md` - Mark task 4.4.1 complete

## Status

- **Current Step:** Complete
- **Tests:** 58 tests (18 doctests + 40 unit tests), 0 failures
- **Dialyzer:** Passes with 0 errors
