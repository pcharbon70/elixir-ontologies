# Feature: Task 4.3.3 - Type Expression Parser

## Overview

Create a type expression parser that parses type expressions from AST into appropriate TypeExpression subclasses, enabling semantic understanding of Elixir type annotations.

## Problem Statement

Type expressions in Elixir come in many forms:
- Basic types: `atom()`, `integer()`, `binary()`, `any()`, `term()`
- Literal types: `:ok`, `1`, `true`
- Union types: `:ok | :error`
- Tuple types: `{atom(), integer()}`
- List types: `[atom()]`, `list(atom())`
- Map types: `%{atom() => term()}`, `map()`
- Function types: `(integer() -> atom())`
- Remote types: `String.t()`, `GenServer.on_start()`
- Parameterized types: `Enumerable.t(element)`
- Struct types: `%User{}`
- Type variables: `a`, `element`

The parser needs to:
1. Classify type expressions by kind
2. Extract type structure information
3. Handle nested types recursively
4. Provide utilities for type analysis

## Ontology Classes to Support

From `elixir-structure.ttl`:
- `TypeExpression` - Base class for all type expressions
- `BasicType` - Primitive types like atom(), integer()
- `UnionType` - Union of types (type1 | type2)
- `TupleType` - Tuple types ({type1, type2})
- `ListType` - List types ([type])
- `MapType` - Map types (%{key => value})
- `FunctionType` - Function types ((args -> return))
- `ParameterizedType` - Generic types with parameters
- `RemoteType` - Types from other modules (Module.type())
- `TypeVariable` - Type variables in polymorphic types

## AST Patterns Reference

| Type Kind | Example | AST Pattern |
|-----------|---------|-------------|
| Basic | `atom()` | `{:atom, [], []}` |
| Literal atom | `:ok` | `:ok` |
| Literal integer | `1` | `1` |
| Literal boolean | `true` | `true` |
| Union | `:ok \| :error` | `{:\|, [], [:ok, :error]}` |
| 2-tuple | `{a, b}` | `{a_ast, b_ast}` |
| N-tuple | `{a, b, c}` | `{:{}, [], [a, b, c]}` |
| Empty tuple | `{}` | `{:{}, [], []}` |
| List | `[atom()]` | `[{:atom, [], []}]` |
| Empty list | `[]` | `[]` |
| Nonempty list | `[...]` | `[{:..., [], []}]` |
| Map | `%{k => v}` | `{:%{}, [], [{{k_ast}, {v_ast}}]}` |
| Empty map | `%{}` | `{:%{}, [], []}` |
| Function | `(a -> b)` | `[{:->, [], [[a_ast], b_ast]}]` |
| Remote | `String.t()` | `{{:., [], [{:__aliases__, _, [:String]}, :t]}, [], []}` |
| Parameterized | `Enum.t(a)` | `{{:., [], [..., :t]}, [], [a_ast]}` |
| Struct | `%User{}` | `{:%, [], [{:__aliases__, _, [:User]}, {:%{}, [], []}]}` |
| Variable | `a` | `{:a, [], context}` |

## Implementation Plan

### Step 1: Create Type Expression Module
- [x] Create `lib/elixir_ontologies/extractors/type_expression.ex`
- [x] Define `TypeExpression` result struct
- [x] Define type kind enum

### Step 2: Implement Basic Type Parsing
- [x] Parse basic types: atom(), integer(), binary(), etc.
- [x] Parse literal types: :ok, 1, true, false, nil
- [x] Detect and classify basic type calls

### Step 3: Implement Union Type Parsing
- [x] Parse union operator `|`
- [x] Flatten nested unions into list
- [x] Handle union of any types

### Step 4: Implement Tuple Type Parsing
- [x] Parse 2-tuple `{a, b}`
- [x] Parse N-tuple `{:{}, [], elements}`
- [x] Parse empty tuple `{}`

### Step 5: Implement List Type Parsing
- [x] Parse list type `[element]`
- [x] Parse `list(element)` form
- [x] Handle empty list `[]`
- [x] Handle nonempty list `[...]`

### Step 6: Implement Map Type Parsing
- [x] Parse map type `%{key => value}`
- [x] Parse `map()` form
- [x] Handle required/optional keys
- [x] Handle struct types `%User{}`

### Step 7: Implement Function Type Parsing
- [x] Parse function type `(args -> return)`
- [x] Extract parameter types
- [x] Extract return type

### Step 8: Implement Remote Type Parsing
- [x] Parse remote types `Module.type()`
- [x] Extract module and type name
- [x] Handle parameterized remote types

### Step 9: Implement Type Variable Detection
- [x] Detect type variables (bare atoms in type position)
- [x] Distinguish from local type calls

### Step 10: Write Tests
- [x] Test basic type parsing
- [x] Test union type parsing
- [x] Test tuple type parsing
- [x] Test list type parsing
- [x] Test map type parsing
- [x] Test function type parsing
- [x] Test remote type parsing
- [x] Test type variable detection
- [x] Test nested/complex types

## Result Struct Design

```elixir
%TypeExpression{
  kind: :basic | :literal | :union | :tuple | :list | :map | :function | :remote | :struct | :variable | :any,
  name: atom() | nil,
  elements: [TypeExpression.t()] | nil,
  key_type: TypeExpression.t() | nil,
  value_type: TypeExpression.t() | nil,
  param_types: [TypeExpression.t()] | nil,
  return_type: TypeExpression.t() | nil,
  module: [atom()] | nil,
  ast: Macro.t(),
  metadata: map()
}
```

## Success Criteria

- [x] All 10 subtasks from plan completed
- [x] At least 16 tests passing (as specified in plan) - 87 tests (22 doctests + 65 unit tests)
- [x] Doctests for all public functions
- [x] Dialyzer passes with no errors
- [x] Consistent with other extractor patterns

## Files to Create/Modify

### Create
- `lib/elixir_ontologies/extractors/type_expression.ex` - Main parser
- `test/elixir_ontologies/extractors/type_expression_test.exs` - Test file

### Modify
- `notes/planning/phase-04.md` - Mark task 4.3.3 complete

## Status

- **Current Step:** Complete
- **Tests:** 87 tests (22 doctests + 65 unit tests), 0 failures
- **Dialyzer:** Passes with 0 errors
