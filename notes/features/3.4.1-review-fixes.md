# Feature: 3.4.1 Review Fixes and Improvements

## Overview

Address all concerns and implement suggestions from the code review of Task 3.4.1 - Control Flow Extractor Module.

## Review Reference

See: `notes/reviews/3.4.1-control-flow-extractor-review.md`

## Implementation Plan

### Concerns to Fix (Priority)

- [ ] 1. Fix location extraction inconsistency - pass full node instead of synthetic
- [ ] 2. Add validation for empty `with` args
- [ ] 3. Add fallback patterns for clause extraction helpers
- [ ] 4. Add `@moduledoc` and `doctest` to test file

### Suggested Improvements

- [ ] 5. Create shared `ElixirOntologies.Extractors.Helpers` module
- [ ] 6. Refactor if/unless to use shared builder function
- [ ] 7. Document clause ordering semantics in `@moduledoc`
- [ ] 8. Add convenience validation functions (`has_else?/1`, `has_timeout?/1`)
- [ ] 9. Add recursion depth limits for security hardening
- [ ] 10. Limit error message size with inspect options

## Files to Modify/Create

### Create
- `lib/elixir_ontologies/extractors/helpers.ex` - Shared extractor utilities

### Modify
- `lib/elixir_ontologies/extractors/control_flow.ex` - All fixes and improvements
- `lib/elixir_ontologies/extractors/pattern.ex` - Use shared helpers
- `lib/elixir_ontologies/extractors/operator.ex` - Use shared helpers
- `lib/elixir_ontologies/extractors/literal.ex` - Use shared helpers
- `test/elixir_ontologies/extractors/control_flow_test.exs` - Add moduledoc/doctest

## Technical Details

### 1. Shared Helpers Module

```elixir
defmodule ElixirOntologies.Extractors.Helpers do
  @moduledoc """
  Shared utility functions for extractor modules.
  """

  alias ElixirOntologies.Analyzer.Location

  @doc """
  Extracts source location from an AST node.
  """
  def extract_location(node)
  def extract_location({_form, meta, _args} = node) when is_list(meta) do
    case Location.extract_range(node) do
      {:ok, location} -> location
      _ -> nil
    end
  end
  def extract_location(_), do: nil

  @doc """
  Combines multiple guard expressions into a single `and` expression.
  """
  def combine_guards([single]), do: single
  def combine_guards([first | rest]), do: {:and, [], [first, combine_guards(rest)]}
  def combine_guards([]), do: nil
end
```

### 2. Conditional Builder Function

```elixir
defp build_conditional(type, meta, condition, opts) do
  then_branch = Keyword.get(opts, :do)
  else_branch = Keyword.get(opts, :else)

  %__MODULE__{
    type: type,
    condition: condition,
    clauses: [],
    branches: %{then: then_branch, else: else_branch},
    location: Helpers.extract_location({type, meta, [condition, opts]}),
    metadata: %{has_else: else_branch != nil}
  }
end
```

### 3. Convenience Functions

```elixir
def has_else?(%__MODULE__{metadata: %{has_else: has_else}}), do: has_else
def has_else?(_), do: false

def has_timeout?(%__MODULE__{metadata: %{has_timeout: has_timeout}}), do: has_timeout
def has_timeout?(_), do: false

def has_rescue?(%__MODULE__{metadata: %{has_rescue: has_rescue}}), do: has_rescue
def has_rescue?(_), do: false
```

### 4. Depth-Limited Recursion

Add `@max_recursion_depth` constant and depth parameter to recursive functions.

## Success Criteria

- [ ] All tests pass (existing + new)
- [ ] All 4 extractors use shared Helpers module
- [ ] No code duplication for location extraction
- [ ] Edge cases handled gracefully (empty args, malformed clauses)
- [ ] Error messages limited in size
- [ ] Documentation complete

## Status

- **Current Step:** Creating planning document
- **Next Step:** Fix location extraction
