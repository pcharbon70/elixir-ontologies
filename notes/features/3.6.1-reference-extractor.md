# Feature: 3.6.1 Variable and Reference Extractor Module

## Overview

Implement the Reference extractor module that analyzes Elixir AST nodes representing variables, module references, function captures, and function calls.

## AST Structure Analysis

Based on exploration of Elixir's reference AST:

```elixir
# Variable
{:x, [], Elixir}

# Module reference (alias)
{:__aliases__, [alias: false], [:MyModule]}

# Nested module
{:__aliases__, [alias: false], [:MyApp, :Users, :Account]}

# Remote function capture: &String.upcase/1
{:&, [], [
  {:/, [], [
    {{:., [], [{:__aliases__, [], [:String]}, :upcase]}, [], []},
    1
  ]}
]}

# Local function capture: &my_func/2
{:&, [], [
  {:/, [], [{:my_func, [], Elixir}, 2]}
]}

# Anonymous capture: &(&1 + &2)
{:&, [], [expression_with_placeholders]}

# Remote call: String.upcase("hello")
{{:., [], [{:__aliases__, [], [:String]}, :upcase]}, [], ["hello"]}

# Local call: my_function(1, 2)
{:my_function, [], [1, 2]}

# Erlang module call: :erlang.now()
{{:., [], [:erlang, :now]}, [], []}

# Variable binding: x = 1
{:=, [], [{:x, [], Elixir}, 1]}

# Pin operator: ^x
{:^, [], [{:x, [], Elixir}]}
```

## Reference Types to Extract

1. **Variable** - Simple variable reference
2. **ModuleReference** - Module alias (MyModule, MyApp.Users)
3. **FunctionCapture** - Captured function (&func/arity)
4. **RemoteCall** - Module.function(args)
5. **LocalCall** - function(args)
6. **Binding** - Variable assignment (x = value)
7. **Pin** - Pinned variable (^x)

## Implementation Plan

### 1. Create Module Structure
- [x] 3.6.1.1 Create `lib/elixir_ontologies/extractors/reference.ex`
- [x] Define result structs for each reference type
- [x] Use shared Helpers module

### 2. Reference Extraction
- [x] 3.6.1.2 Extract `Variable` with name
- [x] 3.6.1.3 Extract `ModuleReference` (alias references)
- [x] 3.6.1.4 Extract `FunctionReference` (captured functions)
- [x] 3.6.1.5 Extract `RemoteCall` (Module.function(args))
- [x] 3.6.1.6 Extract `LocalCall` (function(args))
- [x] 3.6.1.7 Add `refersToModule`, `refersToFunction` properties
- [x] 3.6.1.8 Track variable scope and rebinding

### 3. Testing
- [x] 3.6.1.9 Write reference tests

## Result Struct Design

```elixir
%Reference{
  type: :variable | :module | :function_capture | :remote_call | :local_call | :binding | :pin,
  name: atom() | [atom()],
  module: [atom()] | nil,
  function: atom() | nil,
  arity: non_neg_integer() | nil,
  arguments: [Macro.t()] | nil,
  value: Macro.t() | nil,  # for bindings
  location: SourceLocation.t() | nil,
  metadata: map()
}
```

## Test Cases

1. Simple variable reference
2. Module reference (single and nested)
3. Remote function capture (&Mod.fun/n)
4. Local function capture (&fun/n)
5. Anonymous function capture (&(&1 + &2))
6. Remote call (Module.function(args))
7. Local call (function(args))
8. Erlang module call (:erlang.term())
9. Variable binding (x = value)
10. Pin operator (^x)
11. Qualified calls (Kernel.+/2)
12. Call with no arguments

## Files to Create/Modify

### Create
- `lib/elixir_ontologies/extractors/reference.ex`
- `test/elixir_ontologies/extractors/reference_test.exs`

### Modify
- `notes/planning/phase-03.md` - Mark task complete

## Success Criteria

- [ ] All 9 subtasks implemented
- [ ] All tests pass
- [ ] No compilation warnings
- [ ] Doctests included
- [ ] Full test suite passes

## Status

- **Current Step:** Creating planning document
- **Next Step:** Implement module structure
