# Feature: Task 4.2.4 - Return Expression Extractor

## Overview

Create a return expression extractor that identifies and extracts the return expression from function bodies, handling both single-expression and multi-expression function bodies.

## Problem Statement

In Elixir, functions implicitly return the value of their last expression. The extractor needs to:
1. Identify the last expression in a function body
2. Handle single-expression functions (`do: expr`)
3. Handle multi-expression bodies (`do...end` blocks)
4. Handle special control flow that affects return (case, cond, if, with)
5. Preserve the expression AST for further analysis

## Ontology Classes to Support

From `elixir-structure.ttl`:
- `ReturnExpression` - The expression that a function returns
- `FunctionBody` with `returnsExpression` property

## Implementation Plan

### Step 1: Create Return Expression Extractor Module
- [x] Create `lib/elixir_ontologies/extractors/return_expression.ex`
- [x] Define `ReturnExpression` result struct
- [x] Add type detection helpers

### Step 2: Implement ReturnExpression.extract/2
- [x] Accept function body AST and optional context
- [x] Return `{:ok, %ReturnExpression{}}` or `{:error, reason}`
- [x] Add `extract!/2` that raises on error

### Step 3: Handle Single Expression Bodies
- [x] Handle `do: expr` format (already extracted value)
- [x] Handle literal values (atoms, numbers, strings)
- [x] Handle simple expressions

### Step 4: Handle Multi-Expression Bodies
- [x] Handle `{:__block__, _, exprs}` format
- [x] Extract last expression from block
- [x] Preserve expression context

### Step 5: Handle Control Flow Returns
- [x] Detect `case` expressions (returns from branches)
- [x] Detect `cond` expressions
- [x] Detect `if/unless` expressions
- [x] Detect `with` expressions
- [x] Flag as `multi_return: true` when applicable

### Step 6: Extract Expression Metadata
- [x] Determine expression type (literal, call, control_flow, etc.)
- [x] Extract location information
- [x] Add relevant metadata

### Step 7: Write Tests
- [x] Test single expression extraction
- [x] Test block expression extraction
- [x] Test control flow expressions
- [x] Test literal returns
- [x] Test nil/empty body handling

## Result Struct Design

```elixir
%ReturnExpression{
  expression: Macro.t(),
  type: :literal | :variable | :call | :control_flow | :block | :other,
  location: SourceLocation.t() | nil,
  metadata: %{
    multi_return: boolean(),   # true for case/cond/if
    control_type: atom() | nil, # :case, :cond, :if, etc.
    is_nil: boolean()
  }
}
```

## Success Criteria

- [x] All 6 subtasks from plan completed
- [x] At least 8 tests passing (as specified in plan) - 60 tests (16 doctests + 44 unit tests)
- [x] Doctests for all public functions
- [x] Dialyzer passes with no errors
- [x] Consistent with other extractor patterns

## Files to Create/Modify

### Create
- `lib/elixir_ontologies/extractors/return_expression.ex` - Main extractor
- `test/elixir_ontologies/extractors/return_expression_test.exs` - Test file

### Modify
- `notes/planning/phase-04.md` - Mark task 4.2.4 complete

## Status

- **Current Step:** Complete
- **Tests:** 60 tests (16 doctests + 44 unit tests), 0 failures
- **Dialyzer:** Passes with 0 errors
