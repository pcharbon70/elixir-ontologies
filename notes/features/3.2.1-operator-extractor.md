# Feature 3.2.1: Operator Extractor Module

## Overview

Create extractors for all operator types defined in elixir-core.ttl. The module will analyze AST nodes representing operator expressions and produce data structures suitable for RDF generation.

## AST Analysis

All operators in Elixir follow the pattern: `{operator_atom, meta, args}` where args is:
- `[operand]` for unary operators
- `[left_operand, right_operand]` for binary operators

### Operator Categories and AST Patterns

| Category | Operators | AST Example |
|----------|-----------|-------------|
| Arithmetic (binary) | `+`, `-`, `*`, `/`, `div`, `rem` | `{:+, meta, [1, 2]}` |
| Arithmetic (unary) | `-` (negation) | `{:-, meta, [{:x, [], Elixir}]}` |
| Comparison | `==`, `!=`, `===`, `!==`, `<`, `>`, `<=`, `>=` | `{:==, meta, [a, b]}` |
| Logical (binary) | `and`, `or`, `&&`, `\|\|` | `{:and, meta, [a, b]}` |
| Logical (unary) | `not`, `!` | `{:not, meta, [a]}` |
| Pipe | `\|>` | `{:\|>, meta, [input, func]}` |
| Match | `=` | `{:=, meta, [pattern, value]}` |
| Capture | `&` | `{:&, meta, [captured]}` |
| String Concat | `<>` | `{:<>, meta, [left, right]}` |
| List | `++`, `--` | `{:++, meta, [list1, list2]}` |
| Membership | `in` | `{:in, meta, [elem, collection]}` |

### Operator Classification Map

```elixir
@arithmetic_operators [:+, :-, :*, :/, :div, :rem]
@comparison_operators [:==, :!=, :===, :!==, :<, :>, :<=, :>=]
@logical_operators [:and, :or, :not, :&&, :||, :!]
@pipe_operator [:|>]
@match_operator [:=]
@capture_operator [:&]
@string_concat_operator [:<>]
@list_operators [:++, :--]
@in_operator [:in]

# Unary operators (can appear with single operand)
@unary_operators [:-, :not, :!, :&]

# Binary operators (always have two operands)
@binary_operators [:+, :-, :*, :/, :div, :rem, :==, :!=, :===, :!==,
                   :<, :>, :<=, :>=, :and, :or, :&&, :||, :|>,
                   :=, :<>, :++, :--, :in]
```

### Edge Cases

1. **`-` operator**: Can be unary (negation) or binary (subtraction)
   - Unary: `{:-, meta, [operand]}` - single element in args
   - Binary: `{:-, meta, [left, right]}` - two elements

2. **`&` capture operator**: Complex nested structure
   - `&Mod.fun/2`: `{:&, [], [{:/, [], [{{:., [], [mod, fun]}, [], []}, arity]}]}`
   - `&(&1 + &2)`: `{:&, [], [{:+, [], [{:&, [], [1]}, {:&, [], [2]}]}]}`
   - `&foo/1`: `{:&, [], [{:/, [], [{:foo, [], Elixir}, 1]}]}`

3. **`!` vs `not`**: Both are logical negation but different semantics
   - `!` works on any truthy/falsy value
   - `not` only works on boolean values (strict)

## Implementation Plan

### Module Structure

```elixir
defmodule ElixirOntologies.Extractors.Operator do
  @moduledoc """
  Extracts operator expressions from AST nodes.
  """

  defstruct [:type, :operator_class, :symbol, :arity, :operands, :location, :metadata]

  # Main dispatch
  def extract(node)
  def extract!(node)

  # Type detection
  def operator?(node)
  def operator_type(node)
  def operator_class(symbol, arity)

  # Arity detection
  def unary?(node)
  def binary?(node)
end
```

### Result Struct

```elixir
%Operator{
  type: :arithmetic | :comparison | :logical | :pipe | :match |
        :capture | :string_concat | :list | :in,
  operator_class: :UnaryOperator | :BinaryOperator,
  symbol: atom(),           # The operator atom (:+, :==, etc.)
  arity: 1 | 2,
  operands: %{
    left: Macro.t() | nil,  # For binary operators
    right: Macro.t() | nil,
    operand: Macro.t() | nil  # For unary operators
  },
  location: SourceLocation.t() | nil,
  metadata: map()
}
```

### Ontology Mapping

| Operator Type | Ontology Class |
|---------------|----------------|
| `:arithmetic` | `core:ArithmeticOperator` |
| `:comparison` | `core:ComparisonOperator` |
| `:logical` | `core:LogicalOperator` |
| `:pipe` | `core:PipeOperator` |
| `:match` | `core:MatchOperator` |
| `:capture` | `core:CaptureOperator` |
| `:string_concat` | `core:StringConcatOperator` |
| `:list` | `core:ListOperator` |
| `:in` | `core:InOperator` |

Properties:
- `core:operatorSymbol` - string representation of the operator
- `core:hasLeftOperand` - left operand for binary operators
- `core:hasRightOperand` - right operand for binary operators
- `core:hasOperand` - operand for unary operators

## Test Plan

### Test Cases (20+ tests)

1. **Arithmetic operators**: `+`, `-`, `*`, `/`, `div`, `rem`
2. **Unary minus**: `-x` (negation)
3. **Comparison operators**: `==`, `!=`, `===`, `!==`, `<`, `>`, `<=`, `>=`
4. **Logical binary**: `and`, `or`, `&&`, `||`
5. **Logical unary**: `not`, `!`
6. **Pipe operator**: `|>`
7. **Match operator**: `=`
8. **Capture operator**: `&Mod.fun/2`, `&(&1 + 1)`, `&foo/1`
9. **String concat**: `<>`
10. **List operators**: `++`, `--`
11. **In operator**: `in`
12. **Type detection**: `operator?/1`, `operator_type/1`
13. **Arity detection**: `unary?/1`, `binary?/1`
14. **Location extraction**: when metadata present
15. **Error handling**: non-operator nodes

## Files to Create/Modify

- Create: `lib/elixir_ontologies/extractors/operator.ex`
- Create: `test/elixir_ontologies/extractors/operator_test.exs`

## Dependencies

- `ElixirOntologies.Analyzer.Location` for source location extraction
- `ElixirOntologies.NS.Core` for RDF class references (future use)
