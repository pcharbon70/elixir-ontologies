# Feature: Task 4.3.2 - Function Spec Extractor

## Overview

Create a function spec extractor that extracts @spec definitions from AST, including function name, arity, parameter types, return type, and optional `when` type constraints.

## Problem Statement

Elixir function specs (`@spec`) provide type annotations for functions:

```elixir
@spec add(integer(), integer()) :: integer()
@spec fetch(map(), key) :: {:ok, value} | :error when key: atom(), value: term()
@spec identity(a) :: a when a: var
```

Each spec has:
- A function name and arity
- A list of parameter types
- A return type
- Optional `when` clause for type constraints

The extractor needs to:
1. Detect @spec attributes
2. Extract function name and arity
3. Extract parameter types as a list
4. Extract return type
5. Handle `when` clauses with type variable bindings
6. Handle union types in parameters and return

## Ontology Classes to Support

From `elixir-structure.ttl`:
- `FunctionSpec` - Type specification for a function
- `hasSpec` - Links function to spec
- `hasParameterTypes` - Ordered list of parameter types
- `hasReturnType` - The return type expression

## Implementation Plan

### Step 1: Create Function Spec Extractor Module
- [x] Create `lib/elixir_ontologies/extractors/function_spec.ex`
- [x] Define `FunctionSpec` result struct
- [x] Add type detection: `spec?/1`

### Step 2: Implement FunctionSpec.extract/2
- [x] Accept @spec AST and optional context
- [x] Return `{:ok, %FunctionSpec{}}` or `{:error, reason}`
- [x] Add `extract!/2` that raises on error

### Step 3: Extract Function Identity
- [x] Extract function name from spec definition
- [x] Calculate arity from parameter count
- [x] Generate function identifier "name/arity"

### Step 4: Extract Parameter Types
- [x] Extract parameter type list from spec
- [x] Preserve order of parameters
- [x] Handle empty parameter list (arity 0)

### Step 5: Extract Return Type
- [x] Extract return type expression
- [x] Handle union types in return
- [x] Preserve AST for further parsing

### Step 6: Handle When Clauses
- [x] Detect `when` clause in spec
- [x] Extract type variable constraints
- [x] Store as constraint map

### Step 7: Bulk Extraction
- [x] Add `extract_all/1` for module body
- [x] Filter spec attributes
- [x] Return list of FunctionSpec structs

### Step 8: Write Tests
- [x] Test simple spec extraction
- [x] Test spec with multiple parameters
- [x] Test spec with union return type
- [x] Test spec with when clause
- [x] Test parameterized types
- [x] Test error handling

## Result Struct Design

```elixir
%FunctionSpec{
  name: atom(),
  arity: non_neg_integer(),
  parameter_types: [Macro.t()],
  return_type: Macro.t(),
  type_constraints: %{atom() => Macro.t()},
  location: SourceLocation.t() | nil,
  metadata: %{
    has_when_clause: boolean()
  }
}
```

## AST Patterns

Simple spec:
```elixir
# @spec add(integer(), integer()) :: integer()
{:@, [], [{:spec, [], [{:"::", [], [
  {:add, [], [{:integer, [], []}, {:integer, [], []}]},
  {:integer, [], []}
]}]}]}
```

Spec with when clause:
```elixir
# @spec identity(a) :: a when a: var
{:@, [], [{:spec, [], [{:when, [], [
  {:"::", [], [{:identity, [], [{:a, [], nil}]}, {:a, [], nil}]},
  [a: {:var, [], nil}]
]}]}]}
```

## Success Criteria

- [x] All 8 subtasks from plan completed
- [x] At least 12 tests passing (as specified in plan) - 62 tests (19 doctests + 43 unit tests)
- [x] Doctests for all public functions
- [x] Dialyzer passes with no errors
- [x] Consistent with other extractor patterns

## Files to Create/Modify

### Create
- `lib/elixir_ontologies/extractors/function_spec.ex` - Main extractor
- `test/elixir_ontologies/extractors/function_spec_test.exs` - Test file

### Modify
- `notes/planning/phase-04.md` - Mark task 4.3.2 complete

## Status

- **Current Step:** Complete
- **Tests:** 62 tests (19 doctests + 43 unit tests), 0 failures
- **Dialyzer:** Passes with 0 errors
