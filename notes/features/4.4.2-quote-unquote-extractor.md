# Feature: Task 4.4.2 - Quote/Unquote Extractor

## Overview

Create a quote/unquote extractor that extracts metaprogramming constructs from AST, including quote blocks with their options, unquote expressions, and unquote_splicing expressions.

## Problem Statement

Elixir metaprogramming uses three key constructs:
1. `quote do...end` - Converts code to AST representation
2. `unquote(expr)` - Injects values into quoted expressions
3. `unquote_splicing(list)` - Splices list elements into quoted expressions

Quote blocks can have options:
- `bind_quoted: [bindings]` - Bind variables for hygiene
- `context: :match` - Generate match context
- `location: :keep` - Preserve original location
- `unquote: false` - Disable unquote processing

The extractor needs to:
1. Detect quote blocks
2. Extract quote options
3. Find unquote expressions within quotes
4. Find unquote_splicing expressions
5. Analyze nesting of metaprogramming constructs

## Ontology Classes to Support

From `elixir-structure.ttl`:
- `QuotedExpression` - A quote block
- `quotesExpression` - Links quote to its body
- `quoteContext` - The context option (:match, etc.)
- `UnquoteExpression` - An unquote call
- `UnquoteSplicingExpression` - An unquote_splicing call
- `unquotesValue` - Links unquote to its value

## AST Patterns Reference

| Pattern | Example | AST Structure |
|---------|---------|---------------|
| Simple quote | `quote do: expr` | `{:quote, meta, [[do: expr]]}` |
| Quote with options | `quote opts, do: expr` | `{:quote, meta, [opts, [do: expr]]}` |
| unquote | `unquote(x)` | `{:unquote, [], [x]}` |
| unquote_splicing | `unquote_splicing(list)` | `{:unquote_splicing, [], [list]}` |

## Implementation Plan

### Step 1: Create Quote Extractor Module
- [x] Create `lib/elixir_ontologies/extractors/quote.ex`
- [x] Define `QuotedExpression` result struct
- [x] Define `UnquoteExpression` result struct
- [x] Add quote detection: `quote?/1`

### Step 2: Implement QuotedExpression.extract/2
- [x] Accept quote AST and optional context
- [x] Return `{:ok, %QuotedExpression{}}` or `{:error, reason}`
- [x] Extract quote body
- [x] Extract quote options

### Step 3: Extract Quote Options
- [x] Extract `bind_quoted` bindings
- [x] Extract `context` option
- [x] Extract `location` option
- [x] Extract `unquote` option

### Step 4: Implement Unquote Detection
- [x] Detect `unquote` calls
- [x] Detect `unquote_splicing` calls
- [x] Extract unquoted values
- [x] Find all unquotes in a quoted expression

### Step 5: Bulk Extraction
- [x] Add `extract_all_quotes/1` for finding quotes in code
- [x] Add `find_unquotes/1` for finding unquotes in expression

### Step 6: Write Tests
- [x] Test simple quote extraction
- [x] Test quote with options
- [x] Test unquote detection
- [x] Test unquote_splicing detection
- [x] Test nested quotes
- [x] Test find_unquotes

## Result Struct Design

```elixir
%QuotedExpression{
  body: Macro.t(),
  options: %{
    bind_quoted: keyword() | nil,
    context: atom() | nil,
    location: :keep | nil,
    unquote: boolean()
  },
  unquotes: [UnquoteExpression.t()],
  location: SourceLocation.t() | nil,
  metadata: map()
}

%UnquoteExpression{
  kind: :unquote | :unquote_splicing,
  value: Macro.t(),
  location: SourceLocation.t() | nil,
  metadata: map()
}
```

## Success Criteria

- [x] All 7 subtasks from plan completed
- [x] At least 8 tests passing (as specified in plan) - 74 tests (25 doctests + 49 unit tests)
- [x] Doctests for all public functions
- [x] Dialyzer passes with no errors
- [x] Consistent with other extractor patterns

## Files to Create/Modify

### Create
- `lib/elixir_ontologies/extractors/quote.ex` - Main extractor
- `test/elixir_ontologies/extractors/quote_test.exs` - Test file

### Modify
- `notes/planning/phase-04.md` - Mark task 4.4.2 complete

## Status

- **Current Step:** Complete
- **Tests:** 74 tests passing (25 doctests + 49 unit tests)
- **Dialyzer:** Passing with no errors
