# Feature: Task 4.2.1 - Function Definition Extractor

## Overview

Create a function definition extractor that extracts Elixir function definitions from AST, including function name, arity, visibility, type classification, documentation, and type specs.

## Problem Statement

Functions are the core units of Elixir code. The extractor needs to:
1. Extract function identity (name + arity)
2. Classify function type (public, private, guard, delegate)
3. Associate documentation and type specs
4. Handle default parameters for minArity calculation
5. Support module context for IRI generation

## Ontology Classes to Support

From `elixir-structure.ttl`:
- `Function` - Base class with `functionName`, `arity`
- `PublicFunction` - `def` functions
- `PrivateFunction` - `defp` functions
- `GuardFunction` - `defguard`/`defguardp` functions
- `DelegatedFunction` - `defdelegate` with `delegatesTo`

## Implementation Plan

### Step 1: Create Function Extractor Module
- [x] Create `lib/elixir_ontologies/extractors/function.ex`
- [x] Define `Function` result struct
- [x] Add type detection: `function?/1`

### Step 2: Implement Function.extract/2
- [x] Accept AST node and optional context
- [x] Return `{:ok, %Function{}}` or `{:error, reason}`
- [x] Add `extract!/2` that raises on error

### Step 3: Extract Function Identity
- [x] Parse `{:def, meta, [{name, _, args}, body]}` pattern
- [x] Extract function name as atom
- [x] Calculate arity from argument list

### Step 4: Classify Function Types
- [x] Detect `def` as `:public`
- [x] Detect `defp` as `:private`
- [x] Detect `defguard` as `:guard_public`
- [x] Detect `defguardp` as `:guard_private`
- [x] Detect `defdelegate` as `:delegate`

### Step 5: Handle Guard Functions
- [x] Extract guard name and arity
- [x] Store guard expression in metadata

### Step 6: Handle Delegated Functions
- [x] Detect `defdelegate` pattern
- [x] Extract target module and function
- [x] Store `delegates_to` in metadata

### Step 7: Extract Documentation Association
- [x] Accept `doc` option for preceding @doc
- [x] Store docstring in result
- [x] Detect `@doc false` as hidden

### Step 8: Extract Spec Association
- [x] Accept `spec` option for associated @spec
- [x] Store spec AST in metadata

### Step 9: Handle Default Parameters
- [x] Detect `\\` operator in parameters
- [x] Count required vs optional parameters
- [x] Calculate `min_arity`

### Step 10: Module Context
- [x] Accept `module` option for context
- [x] Store module name for IRI generation
- [x] Add helper to generate function IRI

### Step 11: Write Tests
- [x] Test public function extraction
- [x] Test private function extraction
- [x] Test guard function extraction
- [x] Test delegated function extraction
- [x] Test arity calculation
- [x] Test default parameter handling
- [x] Test documentation association
- [x] Test spec association

## Result Struct Design

```elixir
%Function{
  type: :function | :guard | :delegate,
  name: atom(),
  arity: non_neg_integer(),
  min_arity: non_neg_integer(),
  visibility: :public | :private,
  docstring: String.t() | false | nil,
  location: SourceLocation.t() | nil,
  metadata: %{
    module: [atom()] | nil,
    doc_hidden: boolean(),
    spec: Macro.t() | nil,
    delegates_to: {module :: term(), function :: atom(), arity :: non_neg_integer()} | nil,
    has_guards: boolean(),
    default_args: non_neg_integer()
  }
}
```

## Success Criteria

- [x] All 13 subtasks from plan completed
- [x] At least 16 tests passing (as specified in plan) - 80 tests (28 doctests + 52 unit tests)
- [x] Doctests for all public functions
- [x] Dialyzer passes with no errors
- [x] Consistent with Module/Attribute extractor patterns

## Files to Create/Modify

### Create
- `lib/elixir_ontologies/extractors/function.ex` - Main function extractor
- `test/elixir_ontologies/extractors/function_test.exs` - Test file

### Modify
- `notes/planning/phase-04.md` - Mark task 4.2.1 complete

## Status

- **Current Step:** Complete
- **Tests:** 80 tests (28 doctests + 52 unit tests), 0 failures
- **Dialyzer:** Passes with 0 errors
