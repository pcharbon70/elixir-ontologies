# Feature: Task 4.2.5 - Guard Extractor

## Overview

Create a guard extractor that extracts guard clauses from function heads, decomposing combined guards and identifying the guard functions used.

## Problem Statement

Elixir functions can have guards using the `when` keyword. Guards can be:
1. Single guard expressions: `def foo(x) when is_integer(x)`
2. Combined with `and`: `def foo(x) when is_integer(x) and x > 0`
3. Combined with `or`: `def foo(x) when is_integer(x) or is_float(x)`
4. Nested combinations

The extractor needs to:
1. Detect guard clauses in function heads
2. Extract individual guard expressions
3. Decompose combined guards into constituent parts
4. Identify guard functions used (is_integer, is_atom, etc.)

## Ontology Classes to Support

From `elixir-structure.ttl`:
- `GuardClause` - A guard expression on a function clause
- `hasGuard` property linking function head to guard

## Implementation Plan

### Step 1: Create Guard Extractor Module
- [x] Create `lib/elixir_ontologies/extractors/guard.ex`
- [x] Define `Guard` result struct
- [x] Add type detection: `guard?/1`

### Step 2: Implement Guard.extract/2
- [x] Accept guard AST and optional context
- [x] Return `{:ok, %Guard{}}` or `{:error, reason}`
- [x] Add `extract!/2` that raises on error

### Step 3: Handle Single Guards
- [x] Extract single guard function calls
- [x] Extract comparison guards (>, <, ==, etc.)
- [x] Extract pattern matching guards

### Step 4: Handle Combined Guards
- [x] Decompose `and` combined guards
- [x] Decompose `or` combined guards
- [x] Handle nested combinations
- [x] Preserve original expression

### Step 5: Extract Guard Metadata
- [x] Identify guard functions used
- [x] Count guard expressions
- [x] Detect guard type (type_check, comparison, custom)

### Step 6: Extract from Function Clause
- [x] Add `extract_from_clause/1` accepting clause struct
- [x] Extract guard from function head
- [x] Return nil if no guard present

### Step 7: Write Tests
- [x] Test single guard extraction
- [x] Test `and` combined guards
- [x] Test `or` combined guards
- [x] Test nested guard combinations
- [x] Test guard function identification
- [x] Test extraction from clause

## Result Struct Design

```elixir
%Guard{
  expression: Macro.t(),
  expressions: [Macro.t()],
  combinator: :none | :and | :or | :mixed,
  guard_functions: [atom()],
  location: SourceLocation.t() | nil,
  metadata: %{
    count: non_neg_integer(),
    has_comparison: boolean(),
    has_type_check: boolean()
  }
}
```

## Success Criteria

- [x] All 5 subtasks from plan completed
- [x] At least 8 tests passing (as specified in plan) - 66 tests (22 doctests + 44 unit tests)
- [x] Doctests for all public functions
- [x] Dialyzer passes with no errors
- [x] Consistent with other extractor patterns

## Files to Create/Modify

### Create
- `lib/elixir_ontologies/extractors/guard.ex` - Main extractor
- `test/elixir_ontologies/extractors/guard_test.exs` - Test file

### Modify
- `notes/planning/phase-04.md` - Mark task 4.2.5 complete

## Status

- **Current Step:** Complete
- **Tests:** 66 tests (22 doctests + 44 unit tests), 0 failures
- **Dialyzer:** Passes with 0 errors
