# Feature: 3.5.1 Comprehension Extractor Module

## Overview

Implement the Comprehension extractor module that analyzes Elixir AST nodes representing `for` comprehensions and extracts their generators, filters, options, and body expressions.

## AST Structure Analysis

Based on exploration of Elixir's `for` comprehension AST:

```elixir
# Simple: for x <- [1,2,3], do: x * 2
{:for, [], [
  {:<-, [], [{:x, [], Elixir}, [1, 2, 3]]},  # generator
  [do: body_ast]                              # options with body
]}

# With filter: for x <- list, x > 2, do: x
{:for, [], [
  {:<-, [], [{:x, [], Elixir}, [1, 2, 3, 4]]},  # generator
  {:>, [], [{:x, [], Elixir}, 2]},              # filter (non-generator expression)
  [do: {:x, [], Elixir}]                        # options
]}

# Bitstring generator: for <<c <- "hello">>, do: c + 1
{:for, [], [
  {:<<>>, [], [{:<-, [], [{:c, [], Elixir}, "hello"]}]},  # bitstring generator
  [do: body_ast]
]}

# With into: for {k, v} <- map, into: %{}, do: {k, v}
{:for, [], [
  {:<-, [], [pattern, enumerable]},
  [into: collector_ast, do: body_ast]
]}

# With reduce: for x <- list, reduce: 0 do acc -> acc + x end
{:for, [], [
  {:<-, [], [{:x, [], Elixir}, list]},
  [reduce: initial_value],
  [do: [{:->, [], [[acc_pattern], body]}]]  # clauses for reduce
]}
```

## Components to Extract

1. **Generators** - `{:<-, [], [pattern, enumerable]}` forms
2. **Bitstring Generators** - `{:<<>>, [], [{:<-, [], [pattern, binary]}]}` forms
3. **Filters** - Any expression that isn't a generator or options keyword list
4. **Options**:
   - `:do` - Body expression (always present)
   - `:into` - Collection to insert results into
   - `:reduce` - Initial accumulator value
   - `:uniq` - Boolean to filter duplicates

## Implementation Plan

### 1. Create Module Structure

- [ ] 3.5.1.1 Create `lib/elixir_ontologies/extractors/comprehension.ex`
- [ ] Define result structs for Comprehension, Generator, and Filter
- [ ] Use shared Helpers module for location extraction

### 2. Type Detection

- [ ] `comprehension?/1` - Check if AST is a for comprehension
- [ ] Distinguish regular vs bitstring generators
- [ ] Identify filter expressions

### 3. Main Extraction

- [ ] 3.5.1.2 Extract `ForComprehension` with body expression
- [ ] 3.5.1.3 Extract `Generator` (pattern <- enumerable)
- [ ] 3.5.1.4 Extract `BitstringGenerator` (pattern <<- bitstring)
- [ ] 3.5.1.5 Extract `Filter` (boolean expressions)

### 4. Relationship Linking

- [ ] 3.5.1.6 Link generators via `hasGenerator`
- [ ] 3.5.1.7 Link filters via `hasFilter`
- [ ] 3.5.1.8 Extract `:into` option as `hasIntoCollector`
- [ ] 3.5.1.9 Extract `:reduce` option

### 5. Testing

- [ ] 3.5.1.10 Write comprehension tests

## Result Struct Design

```elixir
%Comprehension{
  type: :for,
  generators: [generator()],
  filters: [Macro.t()],
  body: Macro.t(),
  options: %{
    into: Macro.t() | nil,
    reduce: Macro.t() | nil,
    uniq: boolean()
  },
  location: SourceLocation.t() | nil,
  metadata: %{
    generator_count: non_neg_integer(),
    filter_count: non_neg_integer(),
    has_into: boolean(),
    has_reduce: boolean(),
    has_uniq: boolean()
  }
}

# Generator types
%{
  type: :generator | :bitstring_generator,
  pattern: Macro.t(),
  enumerable: Macro.t(),
  location: SourceLocation.t() | nil
}
```

## Test Cases

1. Simple comprehension with single generator
2. Multiple generators (nested loops)
3. With filter expression
4. Multiple filters
5. With `:into` option (map, list, etc.)
6. With `:reduce` option
7. Bitstring generator
8. Pattern matching in generator
9. With `:uniq` option
10. Complex comprehension with all features

## Files to Create/Modify

### Create
- `lib/elixir_ontologies/extractors/comprehension.ex`
- `test/elixir_ontologies/extractors/comprehension_test.exs`

### Modify
- `notes/planning/phase-03.md` - Mark task complete

## Success Criteria

- [ ] All 10 subtasks implemented
- [ ] All tests pass
- [ ] No compilation warnings
- [ ] Doctests included for main functions
- [ ] Full test suite passes

## Status

- **Current Step:** Creating planning document
- **Next Step:** Implement module structure
