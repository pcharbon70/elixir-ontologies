# Feature 1.3.1: IRI Builder Module

## Problem Statement

The Knowledge Graph tooling needs to generate stable, readable IRIs for all code elements. Without a consistent IRI generation strategy, the same code element could get different IRIs across analyses, breaking graph queries and provenance tracking.

IRIs must:
- Be stable (same code element = same IRI)
- Be readable (reflect Elixir's identity model)
- Handle special characters in Elixir names (!, ?, operators)
- Support all code element types (modules, functions, clauses, parameters, files, etc.)

## Solution Overview

Create an `ElixirOntologies.IRI` module that generates path-based IRIs following Elixir's identity model:
- Modules: `base:ModuleName`
- Functions: `base:Module/function_name/arity`
- Clauses: `function_iri/clause/N`
- Parameters: `clause_iri/param/N`
- Files: `base:file/path/to/file.ex`
- Source locations: `file_iri/L{start}-{end}`
- Repositories: `base:repo/{hash}`
- Commits: `repo_iri/commit/{sha}`

## Technical Details

### IRI Patterns

| Element | Pattern | Example |
|---------|---------|---------|
| Module | `{base}{ModuleName}` | `https://example.org/code#MyApp.Users` |
| Function | `{base}{Module}/{name}/{arity}` | `https://example.org/code#MyApp.Users/get_user/1` |
| Clause | `{function_iri}/clause/{N}` | `https://example.org/code#MyApp.Users/get_user/1/clause/0` |
| Parameter | `{clause_iri}/param/{N}` | `https://example.org/code#MyApp.Users/get_user/1/clause/0/param/0` |
| File | `{base}file/{path}` | `https://example.org/code#file/lib/my_app/users.ex` |
| Location | `{file_iri}/L{start}-{end}` | `https://example.org/code#file/lib/my_app/users.ex/L10-25` |
| Repository | `{base}repo/{hash}` | `https://example.org/code#repo/a1b2c3d4` |
| Commit | `{repo_iri}/commit/{sha}` | `https://example.org/code#repo/a1b2c3d4/commit/abc123` |

### Special Character Handling

Elixir allows special characters in function names that need escaping in IRIs:
- `?` → `%3F` (e.g., `valid?` → `valid%3F`)
- `!` → `%21` (e.g., `update!` → `update%21`)
- Operators need URL encoding (e.g., `|>` → `%7C%3E`)

### File Location

`lib/elixir_ontologies/iri.ex`

## Implementation Plan

- [x] 1.3.1.1 Create `lib/elixir_ontologies/iri.ex` module with escape_name/1 helper
- [x] 1.3.1.2 Implement `IRI.for_module(base_iri, module_name)`
- [x] 1.3.1.3 Implement `IRI.for_function(base_iri, module, name, arity)`
- [x] 1.3.1.4 Implement `IRI.for_clause(function_iri, clause_order)`
- [x] 1.3.1.5 Implement `IRI.for_parameter(clause_iri, position)`
- [x] 1.3.1.6 Implement `IRI.for_source_file(base_iri, relative_path)`
- [x] 1.3.1.7 Implement `IRI.for_source_location(file_iri, start_line, end_line)`
- [x] 1.3.1.8 Implement `IRI.for_repository(base_iri, repo_url)`
- [x] 1.3.1.9 Implement `IRI.for_commit(repo_iri, sha)`
- [x] 1.3.1.10 Write IRI generation tests (45 tests pass)

## Success Criteria

- [x] All IRI generation functions implemented
- [x] Special characters properly escaped
- [x] Generated IRIs are valid RDF IRIs
- [x] Tests cover all patterns including edge cases
- [x] IRIs are stable (same input = same output)

## Current Status

**Status**: Complete

### What Works
- `ElixirOntologies.IRI` module with all generation functions
- `escape_name/1` for URL-encoding special characters
- `for_module/2` - Module IRIs
- `for_function/4` - Function IRIs with module/name/arity
- `for_clause/2` - Clause IRIs (0-indexed)
- `for_parameter/2` - Parameter IRIs (0-indexed)
- `for_source_file/2` - Source file IRIs with path normalization
- `for_source_location/3` - Line range IRIs
- `for_repository/2` - Repository IRIs with URL hashing
- `for_commit/2` - Commit IRIs
- 45 tests covering all patterns and edge cases

### API Summary

```elixir
alias ElixirOntologies.IRI

base = "https://example.org/code#"

# Module IRI
IRI.for_module(base, "MyApp.Users")
#=> ~I<https://example.org/code#MyApp.Users>

# Function IRI
IRI.for_function(base, "MyApp.Users", "get_user", 1)
#=> ~I<https://example.org/code#MyApp.Users/get_user/1>

# Function with special characters
IRI.for_function(base, "MyApp", "valid?", 1)
#=> ~I<https://example.org/code#MyApp/valid%3F/1>

# Clause IRI (compose from function)
func_iri = IRI.for_function(base, "MyApp", "get", 1)
IRI.for_clause(func_iri, 0)
#=> ~I<https://example.org/code#MyApp/get/1/clause/0>

# Parameter IRI (compose from clause)
clause_iri = IRI.for_clause(func_iri, 0)
IRI.for_parameter(clause_iri, 0)
#=> ~I<https://example.org/code#MyApp/get/1/clause/0/param/0>

# Source file
IRI.for_source_file(base, "lib/my_app/users.ex")
#=> ~I<https://example.org/code#file/lib/my_app/users.ex>

# Source location
file_iri = IRI.for_source_file(base, "lib/users.ex")
IRI.for_source_location(file_iri, 10, 25)
#=> ~I<https://example.org/code#file/lib/users.ex/L10-25>

# Repository (URL is hashed)
IRI.for_repository(base, "https://github.com/user/repo")
#=> ~I<https://example.org/code#repo/a1b2c3d4>

# Commit
repo_iri = IRI.for_repository(base, "https://github.com/user/repo")
IRI.for_commit(repo_iri, "abc123")
#=> ~I<https://example.org/code#repo/a1b2c3d4/commit/abc123>
```

### How to Test
```bash
mix test test/elixir_ontologies/iri_test.exs
```
