# Feature: Task 4.1.1 - Module Extractor Module

## Overview

Create a comprehensive module extractor that extracts Elixir module definitions from AST, including module name, nested modules, documentation, and directives (alias, import, require, use).

## Problem Statement

Phase 4 introduces structure extractors that work at a higher level than the core extractors from Phase 3. The Module extractor is the foundation - it extracts module definitions which contain functions, macros, types, and attributes.

## Ontology Classes to Support

From `elixir-structure.ttl`:
- `Module` - Main module class with `moduleName`
- `NestedModule` - Module defined inside another (has `parentModule`)
- `ModuleAlias` - `alias` directive
- `Import` - `import` directive with `:only`/`:except`
- `Require` - `require` directive
- `Use` - `use` directive

## Implementation Plan

### Step 1: Create Module Extractor Module
- [x] Create `lib/elixir_ontologies/extractors/module.ex`
- [x] Define `Module` result struct with fields: type, name, docstring, aliases, imports, requires, uses, attributes, functions, macros, types, location, metadata
- [x] Add type detection: `module?/1`

### Step 2: Implement Module.extract/2
- [x] Accept AST node and optional context (for parent module)
- [x] Return `{:ok, %Module{}}` or `{:error, reason}`
- [x] Add `extract!/2` that raises on error

### Step 3: Extract Module Name
- [x] Parse `{:defmodule, meta, [{:__aliases__, _, parts}, [do: body]]}`
- [x] Handle single-segment and multi-segment module names
- [x] Store as list of atoms in `name` field

### Step 4: Detect Nested Modules
- [x] Accept optional `parent_module` in context
- [x] Set `type: :nested_module` when parent exists
- [x] Store parent reference in metadata

### Step 5: Extract @moduledoc
- [x] Find `{:@, _, [{:moduledoc, _, [content]}]}` in module body
- [x] Handle string, heredoc, and `false` values
- [x] Store in `docstring` field

### Step 6: Extract Directives
- [x] Extract `alias` as `ModuleAlias` structs
- [x] Extract `import` as `Import` structs with `:only`/`:except`
- [x] Extract `require` as `Require` structs
- [x] Extract `use` as `Use` structs with options

### Step 7: Collect Contained Definitions
- [x] Find `def`, `defp` for functions (names only, full extraction in 4.2)
- [x] Find `defmacro`, `defmacrop` for macros
- [x] Find `@type`, `@typep`, `@opaque` for types
- [x] Store as lists of definition descriptors

### Step 8: Write Tests
- [x] Test simple module extraction
- [x] Test nested module detection
- [x] Test @moduledoc extraction
- [x] Test alias/import/require/use extraction
- [x] Test function/macro/type collection
- [x] Test error handling

## Result Struct Design

```elixir
%Module{
  type: :module | :nested_module,
  name: [atom()],  # e.g., [:MyApp, :Users]
  docstring: String.t() | false | nil,
  aliases: [%{module: [atom()], as: atom() | nil}],
  imports: [%{module: [atom()], only: keyword() | nil, except: keyword() | nil}],
  requires: [%{module: [atom()]}],
  uses: [%{module: [atom()], opts: keyword()}],
  functions: [%{name: atom(), arity: non_neg_integer(), visibility: :public | :private}],
  macros: [%{name: atom(), arity: non_neg_integer(), visibility: :public | :private}],
  types: [%{name: atom(), visibility: :public | :private | :opaque}],
  location: SourceLocation.t() | nil,
  metadata: %{
    parent_module: [atom()] | nil,
    has_moduledoc: boolean()
  }
}
```

## Success Criteria

- [x] All 12 subtasks from plan completed
- [x] At least 18 tests passing (as specified in plan) - 61 tests (14 doctests + 47 unit tests)
- [x] Doctests for all public functions
- [x] Dialyzer passes with no errors
- [x] Consistent with Phase 3 extractor patterns

## Files to Create/Modify

### Create
- `lib/elixir_ontologies/extractors/module.ex` - Main module extractor
- `test/elixir_ontologies/extractors/module_test.exs` - Test file

### Modify
- `notes/planning/phase-04.md` - Mark task 4.1.1 complete

## Status

- **Current Step:** Complete
- **Tests:** 61 tests (14 doctests + 47 unit tests), 0 failures
- **Dialyzer:** Passes with 0 errors
