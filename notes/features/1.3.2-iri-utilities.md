# Feature 1.3.2: IRI Utilities

## Problem Statement

Task 1.3.1 implemented IRI generation, but we also need utility functions to:
- Parse IRIs back into their component parts
- Validate that IRIs follow the expected patterns
- Extract module names and function signatures from IRIs

These utilities enable round-trip operations (generate → use → parse) and validation of IRI integrity.

## Solution Overview

Extend the `ElixirOntologies.IRI` module with utility functions:
- `parse/1` - Extract components from an IRI into a structured map
- `valid?/1` - Validate IRI format (delegates to RDF.IRI.valid?/1)
- `module_from_iri/1` - Extract module name from a module or function IRI
- `function_from_iri/1` - Extract {module, name, arity} tuple from function IRI

Note: `escape_name/1` was already implemented in task 1.3.1.

## Technical Details

### Parse Result Structure

```elixir
%{
  type: :module | :function | :clause | :parameter | :file | :location | :repository | :commit,
  base_iri: "https://example.org/code#",
  # Type-specific fields:
  module: "MyApp.Users",           # for module/function
  function: "get_user",            # for function
  arity: 1,                        # for function
  clause: 0,                       # for clause
  parameter: 0,                    # for parameter
  path: "lib/my_app/users.ex",     # for file
  start_line: 10,                  # for location
  end_line: 25,                    # for location
  repo_hash: "a1b2c3d4",           # for repository
  sha: "abc123"                    # for commit
}
```

### IRI Patterns to Parse

| Pattern | Type | Regex |
|---------|------|-------|
| `base#Module.Name` | `:module` | `^(.+#)([A-Z][A-Za-z0-9_.]+)$` |
| `base#Module/func/N` | `:function` | `^(.+#)([A-Z][A-Za-z0-9_.]+)/([^/]+)/(\d+)$` |
| `.../clause/N` | `:clause` | `.+/clause/(\d+)$` |
| `.../param/N` | `:parameter` | `.+/param/(\d+)$` |
| `base#file/path` | `:file` | `^(.+#)file/(.+)$` |
| `.../L{start}-{end}` | `:location` | `.+/L(\d+)-(\d+)$` |
| `base#repo/hash` | `:repository` | `^(.+#)repo/([a-f0-9]+)$` |
| `.../commit/sha` | `:commit` | `.+/commit/([a-f0-9]+)$` |

### File Location

`lib/elixir_ontologies/iri.ex` (extend existing module)

## Implementation Plan

- [x] 1.3.2.1 Implement `IRI.parse/1` to extract components from an IRI
- [x] 1.3.2.2 Implement `IRI.valid?/1` to validate IRI format
- [x] 1.3.2.3 Implement `IRI.module_from_iri/1` to extract module name
- [x] 1.3.2.4 Implement `IRI.function_from_iri/1` to extract {module, name, arity}
- [x] 1.3.2.5 Write utility tests (43 new tests)
- [x] 1.3.2.6 Add round-trip tests (generate → parse → verify)

## Success Criteria

- [x] All utility functions implemented
- [x] Parse correctly identifies IRI types
- [x] Round-trip tests pass (generate → parse → components match)
- [x] Tests cover all IRI patterns

## Current Status

**Status**: Complete

### What Works
- `IRI.valid?/1` - delegates to RDF.IRI.valid?/1
- `IRI.parse/1` - parses any IRI into component map with type detection
- `IRI.module_from_iri/1` - extracts module name from module/function/clause/parameter IRIs
- `IRI.function_from_iri/1` - extracts {module, name, arity} from function/clause/parameter IRIs
- `IRI.unescape_name/1` - inverse of escape_name/1
- 88 total tests (45 from 1.3.1 + 43 new)

### API Summary

```elixir
alias ElixirOntologies.IRI

# Validate IRI
IRI.valid?(RDF.iri("https://example.org/code#MyApp"))
#=> true

# Parse IRI into components
{:ok, %{type: :function, module: "MyApp", function: "get", arity: 1}} =
  IRI.parse(RDF.iri("https://example.org/code#MyApp/get/1"))

# Extract module name
{:ok, "MyApp.Users"} = IRI.module_from_iri(RDF.iri("https://example.org/code#MyApp.Users/get/1"))

# Extract function signature
{:ok, {"MyApp", "valid?", 1}} = IRI.function_from_iri(RDF.iri("https://example.org/code#MyApp/valid%3F/1"))

# Unescape URL-encoded names
IRI.unescape_name("valid%3F")
#=> "valid?"
```

### How to Test
```bash
mix test test/elixir_ontologies/iri_test.exs
```
