# Feature: Task 4.2.2 - Function Clause Extractor

## Overview

Create a function clause extractor that extracts individual function clauses from AST, including clause ordering, function head, function body, and support for multi-clause functions.

## Problem Statement

Elixir functions can have multiple clauses (pattern matching). The extractor needs to:
1. Extract individual clauses from function definitions
2. Maintain clause ordering (first match wins)
3. Extract function head (name, parameters, guards)
4. Extract function body
5. Handle bodyless clauses (protocol definitions)

## Ontology Classes to Support

From `elixir-structure.ttl`:
- `FunctionClause` - Individual clause with `clauseOrder`
- `FunctionHead` - Parameters and guards
- `FunctionBody` - The expression(s) in the clause

## Implementation Plan

### Step 1: Create Clause Extractor Module
- [x] Create `lib/elixir_ontologies/extractors/clause.ex`
- [x] Define `Clause` result struct
- [x] Add type detection: `clause?/1`

### Step 2: Implement Clause.extract/2
- [x] Accept AST node and optional context
- [x] Return `{:ok, %Clause{}}` or `{:error, reason}`
- [x] Add `extract!/2` that raises on error

### Step 3: Extract Clause Identity
- [x] Extract function name from clause
- [x] Calculate arity from parameters
- [x] Determine visibility from def/defp

### Step 4: Extract Function Head
- [x] Extract parameter list
- [x] Extract guard expression if present
- [x] Store as head struct in metadata

### Step 5: Extract Function Body
- [x] Handle `do: expr` single expression
- [x] Handle `do...end` block expressions
- [x] Handle bodyless clauses (nil body)

### Step 6: Group Clauses
- [x] Add `group_clauses/1` to group by name/arity
- [x] Assign clause order (1-indexed)
- [x] Return list of clause groups

### Step 7: Extract All Clauses from Module Body
- [x] Add `extract_all/1` for module body
- [x] Filter function definitions
- [x] Group and order clauses

### Step 8: Write Tests
- [x] Test single clause extraction
- [x] Test multi-clause function grouping
- [x] Test clause ordering
- [x] Test function head extraction
- [x] Test function body extraction
- [x] Test bodyless clause handling
- [x] Test guard clause extraction

## Result Struct Design

```elixir
%Clause{
  name: atom(),
  arity: non_neg_integer(),
  visibility: :public | :private,
  order: pos_integer(),
  head: %{
    parameters: [Macro.t()],
    guard: Macro.t() | nil
  },
  body: Macro.t() | nil,
  location: SourceLocation.t() | nil,
  metadata: %{
    function_type: :def | :defp,
    has_guard: boolean(),
    bodyless: boolean()
  }
}
```

## Success Criteria

- [x] All 9 subtasks from plan completed
- [x] At least 12 tests passing (as specified in plan) - 60 tests (20 doctests + 40 unit tests)
- [x] Doctests for all public functions
- [x] Dialyzer passes with no errors
- [x] Consistent with Function extractor patterns

## Files to Create/Modify

### Create
- `lib/elixir_ontologies/extractors/clause.ex` - Main clause extractor
- `test/elixir_ontologies/extractors/clause_test.exs` - Test file

### Modify
- `notes/planning/phase-04.md` - Mark task 4.2.2 complete

## Status

- **Current Step:** Complete
- **Tests:** 60 tests (20 doctests + 40 unit tests), 0 failures
- **Dialyzer:** Passes with 0 errors
