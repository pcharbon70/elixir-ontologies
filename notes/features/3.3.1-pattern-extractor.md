# Feature 3.3.1: Pattern Extractor Module

## Overview

Create extractors for all 11 pattern types defined in elixir-core.ttl. Patterns are fundamental to Elixir's destructuring and pattern matching capabilities.

## AST Analysis

### Pattern Types and AST Representations

| Pattern Type | Example | AST Form |
|--------------|---------|----------|
| Variable | `x` | `{:x, [], Elixir}` |
| Wildcard | `_` | `{:_, [], Elixir}` |
| Pin | `^x` | `{:^, [], [{:x, [], Elixir}]}` |
| Literal | `:ok`, `42`, `"str"` | The literal value itself |
| Tuple | `{a, b}` | `{{:a, [], nil}, {:b, [], nil}}` (2-elem) |
| List | `[a, b]` | `[{:a, [], nil}, {:b, [], nil}]` |
| List (cons) | `[h \| t]` | `[{:\|, [], [{:h, [], nil}, {:t, [], nil}]}]` |
| Map | `%{a: v}` | `{:%{}, [], [a: {:v, [], nil}]}` |
| Struct | `%User{name: n}` | `{:%, [], [{:__aliases__, _, [:User]}, {:%{}, [], [...]}]}` |
| Struct (any) | `%_{name: n}` | `{:%, [], [{:_, [], nil}, {:%{}, [], [...]}]}` |
| Binary | `<<a, b>>` | `{:<<>>, [], [{:a, [], nil}, {:b, [], nil}]}` |
| As | `{:ok, _} = r` | `{:=, [], [left_pattern, {:r, [], nil}]}` |

### Guard Clauses

Guards appear in `when` expressions:
```elixir
{:when, [], [pattern, guard_expression]}
```

Example: `y when is_integer(y)` becomes:
```elixir
{:when, [], [
  {:y, [], Elixir},
  {:is_integer, [...], [{:y, [], Elixir}]}
]}
```

### Key Detection Logic

1. **Variable**: 3-tuple `{atom, meta, context}` where atom is not a special form and context is an atom (usually `Elixir` or `nil`)
2. **Wildcard**: Variable where name is `:_`
3. **Pin**: `{:^, meta, [variable]}`
4. **Literal**: `is_atom/1`, `is_number/1`, `is_binary/1` (non-AST values)
5. **Tuple**: 2-element tuple or `{:{}, meta, elements}` for 3+ elements
6. **List**: `is_list/1` - check for cons cell `{:|, _, _}`
7. **Map**: `{:%{}, meta, pairs}`
8. **Struct**: `{:%, meta, [struct_name, map_ast]}`
9. **Binary**: `{:<<>>, meta, segments}`
10. **As Pattern**: `{:=, meta, [pattern, variable]}` where both sides are patterns

### Edge Cases

1. **Nested patterns**: Patterns can contain other patterns recursively
2. **Binary specifiers**: `<<x::binary-size(4)>>` has complex segment structure
3. **Guards with multiple conditions**: `when a > 0 and b < 10`
4. **Anonymous struct pattern**: `%_{field: val}` uses `_` as struct name
5. **Empty patterns**: `{}`, `[]`, `%{}`

## Implementation Plan

### Module Structure

```elixir
defmodule ElixirOntologies.Extractors.Pattern do
  @moduledoc """
  Extracts patterns from AST nodes.
  """

  defstruct [:type, :value, :bindings, :location, :metadata]

  # Main dispatch
  def extract(node)
  def extract!(node)

  # Type detection
  def pattern?(node)
  def pattern_type(node)

  # Type-specific extractors
  def extract_variable(node)
  def extract_wildcard(node)
  def extract_pin(node)
  def extract_literal(node)
  def extract_tuple(node)
  def extract_list(node)
  def extract_map(node)
  def extract_struct(node)
  def extract_binary(node)
  def extract_as(node)
  def extract_guard(node)
end
```

### Result Struct

```elixir
%Pattern{
  type: :variable | :wildcard | :pin | :literal | :tuple | :list |
        :map | :struct | :binary | :as | :guard,
  value: term(),           # Pattern-specific value
  bindings: [atom()],      # Variables bound by this pattern
  location: SourceLocation.t() | nil,
  metadata: %{
    # Type-specific metadata
    variable_name: atom(),     # For variable/pin
    pinned_variable: atom(),   # For pin
    struct_name: atom() | nil, # For struct (nil = any struct)
    has_cons_cell: boolean(),  # For list
    guard_expression: Macro.t(), # For guard
    nested_patterns: [Pattern.t()], # For compound patterns
  }
}
```

### Ontology Mapping

| Pattern Type | Ontology Class | Key Properties |
|--------------|----------------|----------------|
| `:variable` | `core:VariablePattern` | `bindsVariable` |
| `:wildcard` | `core:WildcardPattern` | - |
| `:pin` | `core:PinPattern` | `pinsVariable` |
| `:literal` | `core:LiteralPattern` | - |
| `:tuple` | `core:TuplePattern` | `hasPattern` (nested) |
| `:list` | `core:ListPattern` | `hasPattern` (nested) |
| `:map` | `core:MapPattern` | `hasPattern` (nested) |
| `:struct` | `core:StructPattern` | `hasPattern` (nested) |
| `:binary` | `core:BinaryPattern` | segment info |
| `:as` | `core:AsPattern` | `hasPattern`, `bindsVariable` |

## Test Plan

### Test Cases (22+ tests)

1. **Variable pattern**: simple variable
2. **Wildcard pattern**: `_`
3. **Pin pattern**: `^x`
4. **Literal patterns**: atom, integer, float, string
5. **Tuple pattern**: 2-elem, 3+ elem, nested
6. **List pattern**: simple, nested, empty
7. **List cons pattern**: `[h|t]`
8. **Map pattern**: atom keys, string keys, nested
9. **Struct pattern**: named struct, any struct `%_`
10. **Binary pattern**: simple, with specifiers
11. **As pattern**: `pattern = var`
12. **Guard extraction**: simple guard, compound guard
13. **Type detection**: `pattern?/1`, `pattern_type/1`
14. **Bindings extraction**: collect bound variables
15. **Nested patterns**: deeply nested structures
16. **Error handling**: non-pattern nodes

## Files to Create/Modify

- Create: `lib/elixir_ontologies/extractors/pattern.ex`
- Create: `test/elixir_ontologies/extractors/pattern_test.exs`

## Dependencies

- `ElixirOntologies.Analyzer.Location` for source location extraction
- `ElixirOntologies.Extractors.Literal` for literal detection
