# Feature 3.1.1: Literal Extractor Module

## Overview

Create extractors for each literal type defined in the elixir-core.ttl ontology. The module will analyze AST nodes representing literals and produce RDF data structures suitable for building RDF graphs.

## AST Analysis

Based on Elixir's `quote` behavior, here are the AST representations for each literal type:

### Primitive Literals (Self-Quoting)
- **Atoms**: `:ok`, `:error`, `true`, `false`, `nil` - quote as themselves
- **Integers**: `42`, `0xFF`, `0o777`, `0b1010` - quote as the integer value
- **Floats**: `3.14`, `1.0e10` - quote as the float value
- **Strings**: `"hello"` - quote as the string (no interpolation)

### Strings with Interpolation
- `"hello #{world}"` becomes `{:<<>>, [], ["hello ", {::, [], [...]}]}`
- Contains `Kernel.to_string/1` call with `from_interpolation: true` metadata

### Collection Literals
- **Lists**: `[1, 2, 3]` quotes as `[1, 2, 3]`
- **Lists with cons**: `[1 | rest]` becomes `[{:|, [], [1, {:rest, [], Elixir}]}]`
- **Tuples**: `{1, 2}` quotes as `{1, 2}` (2-elem tuples are special)
- **Tuples (3+ elements)**: `{:ok, value}` becomes `{:ok, {:value, [], Elixir}}`
- **Keyword lists**: `[name: "John"]` quotes as `[name: "John"]`

### Map Literals
- `%{a: 1}` becomes `{:%{}, [], [a: 1]}`
- `%{"key" => "value"}` becomes `{:%{}, [], [{"key", "value"}]}`

### Binary/Bitstring Literals
- `<<1, 2, 3>>` becomes `{:<<>>, [], [1, 2, 3]}`
- `<<"hello">>` becomes `{:<<>>, [], ["hello"]}`
- With size spec: `<<x::size(8)>>` becomes `{:<<>>, [], [{:"::", [], [...]}]}`

### Sigil Literals
- `~r/pattern/` becomes `{:sigil_r, [delimiter: "/", ...], [{:<<>>, [], ["pattern"]}, []]}`
- `~s(string)` becomes `{:sigil_s, [delimiter: "(", ...], [{:<<>>, [], ["string"]}, []]}`
- `~w(word list)` becomes `{:sigil_w, [delimiter: "(", ...], [{:<<>>, [], ["word list"]}, []]}`
- Modifiers: `~r/pattern/i` puts modifiers in the second arg: `[~c"i"]`

### Range Literals
- `1..10` becomes `{:.., [context: Elixir, ...], [1, 10]}`
- `1..10//2` becomes `{:..//, [context: Elixir, ...], [1, 10, 2]}`

## Implementation Plan

### Module Structure

```elixir
defmodule ElixirOntologies.Extractors.Literal do
  @moduledoc """
  Extracts literal values from AST nodes.
  """

  # Struct to hold extraction results
  defstruct [:type, :value, :location, :metadata]

  # Main dispatch function
  def extract(node)

  # Type detection
  def literal_type(node)
  def literal?(node)

  # Type-specific extractors
  def extract_atom(atom)
  def extract_integer(int)
  def extract_float(float)
  def extract_string(string)
  def extract_list(list)
  def extract_tuple(tuple)
  def extract_map(map_ast)
  def extract_keyword_list(kwlist)
  def extract_binary(binary_ast)
  def extract_charlist(sigil_c)
  def extract_sigil(sigil_ast)
  def extract_range(range_ast)
end
```

### Result Struct

```elixir
%Literal{
  type: :atom | :integer | :float | :string | :list | :tuple |
        :map | :keyword_list | :binary | :charlist | :sigil | :range,
  value: term(),           # The actual value or representation
  location: SourceLocation.t() | nil,
  metadata: %{
    # Type-specific metadata
    interpolated: boolean(),  # For strings
    sigil_char: String.t(),   # For sigils
    sigil_modifiers: [char()],
    range_step: integer() | nil,
    # etc.
  }
}
```

### Detection Functions

1. **Atoms**: `is_atom(node)`
2. **Integers**: `is_integer(node)`
3. **Floats**: `is_float(node)`
4. **Strings**: `is_binary(node)` (plain) or `{:<<>>, _, _}` with interpolation
5. **Lists**: `is_list(node)` and not keyword list pattern
6. **Tuples**: `is_tuple(node)` and not a 3-tuple with atom head (AST node)
7. **Maps**: `{:%{}, _, _}`
8. **Keyword lists**: `is_list(node)` and all elements are `{atom, _}` tuples
9. **Binaries**: `{:<<>>, _, _}` that doesn't look like string interpolation
10. **Charlists**: `{:sigil_c, _, _}`
11. **Sigils**: `{sigil_name, _, _}` where sigil_name starts with `sigil_`
12. **Ranges**: `{:.., _, [_, _]}` or `{:..//, _, [_, _, _]}`

### Edge Cases to Handle

1. **Empty collections**: `[]`, `{}`, `%{}`, `<<>>`
2. **Nested literals**: `[[1, 2], [3, 4]]`, `%{a: %{b: 1}}`
3. **Mixed keyword/non-keyword lists**: `[a: 1, 2]` - not a keyword list
4. **Large tuples**: `{1, 2, 3, 4}` - AST vs value representation
5. **Boolean atoms**: `true`, `false`, `nil` - special atoms
6. **Underscored numbers**: `1_000_000` - parsed as integer

## Test Plan

For each literal type, test:
1. Basic extraction (simple case)
2. Edge cases (empty, nested, special values)
3. Location extraction when available
4. Type detection (`literal_type/1`)
5. Guard function (`literal?/1`)

### Test Cases (24 minimum)

1. `extract_atom/1` - `:ok`, `:error`, `true`, `false`, `nil`
2. `extract_integer/1` - positive, negative, hex notation value
3. `extract_float/1` - standard, scientific notation value
4. `extract_string/1` - simple, with escapes
5. `extract_string/1` - with interpolation (preserves structure)
6. `extract_list/1` - empty, simple, nested
7. `extract_list/1` - cons cell `[h|t]`
8. `extract_tuple/1` - 2-element, larger
9. `extract_map/1` - atom keys, string keys
10. `extract_keyword_list/1` - standard, empty
11. `extract_binary/1` - simple bytes, string content
12. `extract_charlist/1` - sigil_c
13. `extract_sigil/1` - various sigils with modifiers
14. `extract_range/1` - without step, with step
15. `literal_type/1` - returns correct type atom
16. `literal?/1` - true for literals, false for other AST

## Files to Create/Modify

- Create: `lib/elixir_ontologies/extractors/literal.ex`
- Create: `test/elixir_ontologies/extractors/literal_test.exs`

## Dependencies

- `ElixirOntologies.Analyzer.Location` for source location extraction
- `ElixirOntologies.NS.Core` for RDF class references (future use)
